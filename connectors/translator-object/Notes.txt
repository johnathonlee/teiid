To add a new data source implementation, implement the following:

-  Either extend ObjectExecutionFactory or create your own.
-  Implement ObjectSourceProxy, adding vendor specific logic for executing a query and returning a List of Objects



Notes:

Limitations -

1.  There is no current support for 2 or more classes named the same (but different packages) in the same model.  
	The table name will be the name of the class, not the full classname. 
	
2.  Default, columns that are of type object are NOT Selectable or Searchable.  Its assumed that if object types like
	Map, Collection, or Array, there needs to be a related child table that has a foreign key defined.

3.  When using filtering and adding criteria, the column must also be in the SELECT CLAUSE


Modeling -

-   JavaBean convention is used.  The column name (or nameinsource if used) are used in finding the get/is method.

 Example:
    	Object:   Trade
    	Attribute:   TradeId  (getter/setter:  getTradeId/setTradeId)
    	
	   in the Designer, if the column name is not the name of the a attribute, then the nameInSource will have to be set to the Attribute name
	   			example:  	columnName:		TRADE_ID
							nameInSource:   TradeId
								
	The process of getting the trade id value from the Trade object will take the nameInSource (if not provided, then use column name) and prepend "get".
	Therefore, the method name:   getTradeId  must exist on the Trade object.


-	A model should have the hierarchical structure of a class normalized.  Meaning, any container based objects
	(i.e., Collections, Arrays, etc.) must have a separate table defined and have a foreign key relationship to
	its parent table/object. 	
-   The table defined for the root object must have a primary key defined, which is the key to it being found in the cache
-	If an object has children, then the following must occur:
	a.  parent and child tables need a primary key
	b.  if the child object does not contain a reference to the parent object, then the child table will need to have 
		a column added that can be used in the creation of the foreign key (see "c" below) and used in joins
		NOTE:  set these properties on the new column:  
			-	Searchability=UNSEARCHABLE
			-	Selectable=false
			-   Updateable=false
	c.	create the foreign key relationship between parent child, where the NameInSource for the FK being the method 
		(minus the "get") to access child objects.  Example:  method - getLegs   NIS - Legs
	d.  the attribute on an object that is the container object, should not be modeled as an attribute in the table. 
		This is because its not directly queryable.  It should have a related child table, which has a foreign key
		(see b and c above).
	

-  Reverse Engineering the Class Metadata by performing JDBC Import
	-  create a dynamic.vdb so that, in designer, you can do JDBC import using a Teiid connection, in order to reverse engineer
		the class metadata.
	-  NOTE:  The Native Type (i.e., the return type for the "Get" method) does not come thru in the metadata.  The Datdatype and 
		the Native are set the same.
		
		
		
TODO:

-  when importing metadata, make the Object types (of return types, collections, etc) non-selectable, because they need
	to have their own table created and then a foreign key back to the parent table.