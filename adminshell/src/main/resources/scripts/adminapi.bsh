import org.teiid.adminapi.*;

import com.metamatrix.core.util.ObjectConverterUtil;


currentContext().internalVerbose = true;

/**
 * Deploy a {@link VDB} file.
 * @param name  Name of the VDB file to save under
 * @param URL 	VDB file location.
 * @throws AdminException
 *             if there's a system error.
 * @return the {@link VDB} representing the current property values and runtime state.
 */
VDB deployVDB(String vdbFile) {
    debug("Adding VDB " + name + " from " + vdbFile);
    checkAdmin();    
    return internalAdmin.addVDB(vdbFile, new File(vdbFile).toURL());
}

/**
 * Delete the VDB with the given name and version
 * @param vdbName
 * @param version
 * @throws AdminException
 */
void deleteVDB(String name, int version) {
    checkAdmin();
    internalAdmin.deleteVDB(name, version);
}

/**
 * Export VDB to byte array
 *
 * @param vdbName identifier of the {@link VDB}
 * @param vdbVersion {@link VDB} version
 * @return InputStream of the VDB
 * @throws AdminException if there's a system error.
 */
void exportVDB(String name, int vdbVersion, String fileName){
    debug("Exporting VDB " + name + " version " + vdbVersion + " to file " + fileName);
    checkAdmin();
    contents = internalAdmin.exportVDB(name, vdbVersion);
    if (contents != null) {
    	ObjectConverterUtil.write(contents, fileName);
    }
    else {
    	throw new AdminProcessingException("VDB with name "+ name + " is not found to export");
    }
}

/**
 * Deploy a {@link ConnectorBinding} to Configuration
 *
 * @param deployedName  Connector Binding name that will be added to Configuration
 * @param typeName Connector type name. 
 * @param properties Name & Value pair need to deploy the Connector Binding

 * @throws AdminException if there's a system error.
 */
void addConnectorBinding(String deployedName, String typeName, Properties properties) {
    debug("Adding Connector Binding " + deployedName);
    checkAdmin();    
    return internalAdmin.addConnectorBinding(deployedName, typeName, properties);
}

/**
 * Delete the {@link ConnectorBinding} from the Configuration
 *
 * @param deployedName - deployed name of the connector binding
 * @throws AdminException  if there's a system error.
 */
void deleteConnectorBinding(String bindingName) throws AdminException {
    debug("Deleting Connector Binding " + bindingName);
    checkAdmin();    
    internalAdmin.deleteConnectorBinding(bindingName);
}

/**
 * Export a {@link ConnectorBinding} to character Array in XML format
 *
 * @param deployedName the unique identifier for a {@link ConnectorBinding}.
 * @return character Array in XML format
 * @throws AdminException
 *             if there's a system error.
 */
void exportConnectorBinding(String bindingName, String fileName){
    debug("Exporting Connector Binding " + bindingName + " to file " + fileName);
    checkAdmin();
    contents = internalAdmin.exportConnectorBinding(bindingName);
    if (contents != null) {
    	ObjectConverterUtil.write(contents, fileName);	
    }
    else {
    	throw new AdminProcessingException("Connector Binding "+ bindingName + " not found for exporting");
    }
}

/**
 * Assign a {@link ConnectorBinding} to a {@link VDB}'s Model
 *
 * @param vdbName
 *            Name of the VDB
 * @param vdbVersion
 *            Version of the VDB
 * @param modelName
 *            Name of the Model to map Connector Binding
 * @param connectorBindingName
 *            Name of the ConnectorBinding
 * @throws AdminException
 *             if there's a system error or if there's a user input error.
 * @since 4.3
 */
void assignBindingToModel(String vdbName, int vdbVersion, String modelName, String connectorBindingName) {
    debug("Assigning Connector Binding " + connectorBindingName + " to Model " + modelName + " in VDB " + vdbName + " version " + vdbVersion);
    checkAdmin();
    internalAdmin.assignBindingToModel(vdbName, vdbVersion, modelName, connectorBindingName);
}

void assignBindingToModel(String vdbName, int vdbVersion, String modelName, String[] connectorBindingNames) {
    debug("Assigning Connector Bindings " + connectorBindingNames + " to Model " + modelName + " in VDB " + vdbName + " version " + vdbVersion);
    checkAdmin();
    internalAdmin.assignBindingToModel(vdbName, vdbVersion, modelName, connectorBindingNames);
}

/**
 * Adds JDBC XA Data Source in the container.
 * @param dsName - name of the source
 * @param properties - properties
 * @throws AdminException
 */
void addDataSource(String deploymentName, Properties properties) {
    debug("Adding Datasource " + deploymentName);
    checkAdmin();    
    return internalAdmin.addDataSource(deploymentName, properties);	
}

/**
 * Delete data source. 
 * @param dsName
 * @throws AdminException
 */
void deleteDataSource(String deploymentName) {
    debug("Deleting Datasource " + deploymentName);
    checkAdmin();    
    return internalAdmin.deleteDataSource(deploymentName);	
}


/**
 * Get the property definitions for creating the JDBC data source.
 * @return
 * @throws AdminException
 */
Collection getDataSourcePropertyDefinitions(){
    debug("Datasource properties");
    checkAdmin();    
    return internalAdmin.getDataSourcePropertyDefinitions();		
}

/**
 * Add Connector Type, will import Connector Type from a file
 *
 * @param name  of the Connector Type to add
 * @param URL URL to RAR file
 * @throws AdminException  if there's a system error.
 */
void addConnectorType(String name, String rarFile) {
    debug("Adding Connector Type " + name + " from " + rarFile);
    checkAdmin();    
    internalAdmin.addConnectorType(name, new File(rarFile).toURI().toURL());
}


/**
 * Delete Connector Type from Next Configuration
 *
 * @param name String name of the Connector Type to delete
 * @throws AdminException if there's a system error.
 */
void deleteConnectorType(String name){
    debug("Deleting Connector Type " + name);
    checkAdmin();    
    internalAdmin.deleteConnectorType(name);
}

/**
 * Export Connector Type to character array
 * 
 * @param connectorTypeIdentifier
 *            the unique identifier for for a {@link ConnectorType}
 * @param fileName
 *            Name of the file to export to.
 * @throws AdminException
 *             if there's a system error.
 * @since 4.3
 */
void exportConnectorType(String connectorTypeIdentifier, String fileName) {
    debug("Exporting Connector Type " + connectorTypeIdentifier + " to file " + fileName);
    checkAdmin();
    
    contents = internalAdmin.exportConnectorType(connectorTypeIdentifier);
    if (contents != null) {
    	ObjectConverterUtil.write(contents, fileName);
    }
    else {
    	throw new AdminProcessingException("Connector type with name "+ connectorTypeIdentifier + " is not found to export");
    }
}


/**
 * Get all transaction matching the identifier.
 * @return
 * @throws AdminException
 */
Collection getTransactions() {
    checkAdmin();
    result = internalAdmin.getTransactions();
    debug(result);
    return result;	
}

/**
 * Mark the given global transaction as rollback only.
 * @param transactionId
 * @throws AdminException
 */
void terminateTransaction(String transactionId) {
    debug("Terminating transaction = " + transactionId);
    checkAdmin();    
    internalAdmin.terminateTransaction(transactionId);	
}

//** property methods******************************************************************


/**
 * Set/update the property for the Connector Binding identified by the given deployed name.
 * @param deployedName
 * @param propertyName
 * @param propertyValue
 * @throws AdminException
 */
void setConnectorBindingProperty(String deployedName, String propertyName, String propertyValue) {
    debug("Setting property for Connector Binding: "+deployedName+" with property="+propertyName+" value="+propertyValue);
    checkAdmin();    
    internalAdmin.setConnectorBindingProperty(deployedName, propertyName, propertyValue);    
}

/**
 * Assign {@link ConnectorBinding}s to a {@link VDB}'s Model.  If the supplied model does not 
 * support MultiSource bindings, then only the first binding in the supplied array is assigned and
 * the remainder are ignored.
 *
 * @param connectorBindingNames
 *            Names of the ConnectorBindings
 * @param vdbName
 *            Name of the VDB
 * @param vdbVersion
 *            Version of the VDB
 * @param modelName
 *            Name of the Model to map Connector Bindings
 * @throws AdminException
 *             if there's a system error or if there's a user input error.
 */
void assignBindingsToModel(String[] connectorBindingNames, String vdbName, String vdbVersion, String modelName) {
	debug("Assigning the bindings to model");
    checkAdmin();    
    internalAdmin.assignBindingsToModel(connectorBindingNames, vdbName, vdbVersion, modelName);
}

// *********************************************************************************************
//  Monitor Methods
//
// *********************************************************************************************

/**
 * Get the Connector Types available in the configuration.
 *
 * @return Set of connector types.
 * @throws AdminException if there's a system error.
 */
Set getConnectorTypes() {
    checkAdmin();
    result = internalAdmin.getConnectorTypes();
    debug(result);
    return result;
}

/**
 * Get the VDBs that currently deployed in the system
 *
 * @return Collection of {@link VDB}s.  There could be multiple VDBs with the
 * same name in the Collection but they will differ by VDB version.
 * @throws AdminException if there's a system error.
 */
Set getVDBs() {
    checkAdmin();
    result = internalAdmin.getVDBs();
    debug(result);
    return result;
}

/**
 * Get the VDB
 * @param vdbName
 * @param vbdVersion
 * @throws AdminException if there's a system error.
 * @return
 */
VDB getVDB(String vdbName, int version) {
    checkAdmin();
    result = internalAdmin.getVDB(vdbName, version);
    debug(result);
    return result;
}

/**
 * Get all the Connector Bindings for the given VDB identifier pattern
 * @param vdbName - Name of the VDB
 * @param vdbVersion - version of the VDB
 * @return Collection of {@link ConnectorBinding}
 * @throws AdminException if there's a system error.
 * @since 4.3
 */
Collection getConnectorBindingsInVDB(String vdbName, int vdbVersion) {
    checkAdmin();
    result = internalAdmin.getConnectorBindingsInVDB(vdbName, vdbVersion);
    debug(result);
    return result;
}

/**
 * Get the Connector Bindings that are available in the configuration
 *
 * @return Collection of {@link ConnectorBinding}
 * @throws AdminException if there's a system error.
 */
Collection getConnectorBindings() {
    checkAdmin();
    result = internalAdmin.getConnectorBindings();
    debug(result);
    return result;
}


/**
 * Get the connector binding by the given the deployed name.
 * @param deployedName - name of the deployed connector binding
 * @return null if not found a connector binding by the given name
 * @throws AdminException if there's a system error.
 */
ConnectorBinding getConnectorBinding(String deployedName) {
    checkAdmin();
    result = internalAdmin.getConnectorBinding(deployedName);
    debug(result);
    return result;	
}

/**
 * Get the Work Manager stats that correspond to the specified identifier pattern.
 *
 * @param identifier - an identifier for the queues {@link QueueWorkerPool}. "runtime" will return the stats for Query 
 * runtime Worker Pool. Also any Connector Binding name will return the stats for that connector binding.
 * @return Collection of {@link QueueWorkerPool}
 * @throws AdminException if there's a system error.
 */
WorkerPoolStatistics getWorkManagerStats(String identifier) {
    checkAdmin();
    result =internalAdmin.getWorkManagerStats(identifier);
    debug(result);
    return result;
}

/**
 * Get the Connection Pool Stats that correspond to the specified identifier pattern.
 * If the {@link ConnectionPoolStatistics ConnectionPool} represents an XA connection, there
 * will be 2 {@link ConnectionPoolStatistics ConnectionPool}s.  
 *
 * @param deployedName - an identifier that corresponds to the ConnectorBinding Name
 * @return {@link ConnectionPoolStatistics}
 * @throws AdminException if there's a system error.
 */
ConnectionPoolStatistics getConnectorConnectionPoolStats(String deployedName) {
    checkAdmin();
    result =internalAdmin.getConnectorConnectionPoolStats(deployedName);
    debug(result);
    return result;	
}

/**
 * Get the Caches that correspond to the specified identifier pattern
 * @return Collection of {@link String}
 * @throws AdminException if there's a system error.
 */
Collection getCacheTypes() {
    checkAdmin();
    result =internalAdmin.getCacheTypes();
    debug(result);
    return result;
}

/**
 * Get all the current Sessions.
 * @return Collection of {@link Session}
 * @throws AdminException if there's a system error.
 */
Collection getSessions() {
    checkAdmin();
    result =internalAdmin.getSessions();
    debug(result);
    return result;
}

/**
 * Get the all Requests that are currently in process
 * @return Collection of {@link Request}
 * @throws AdminException if there's a system error.
 */
Collection getRequests() {
    checkAdmin();
    result =internalAdmin.getRequests();
    debug(result);
    return result;
}

/**
 * Get the Requests for the given session
 * @return Collection of {@link Request}
 * @throws AdminException if there's a system error.
 */
Collection getRequestsForSession(long sessionId){
    checkAdmin();
    result =internalAdmin.getRequestsForSession(sessionId);
    debug(result);
    return result;	
}

/**
 * Get all of the available Configuration Properties for the specified AdminObject, and details about them.
 * @param connectorTypeIdentifier
 * @return
 * @throws AdminException
 */
Collection getConnectorTypePropertyDefinitions(String identifier){
	checkAdmin();
    result = internalAdmin.getConnectorTypePropertyDefinitions(identifier);
    debug(result);
    return result;	
}

/**
 * Get the processes that correspond to the specified identifier pattern.
 *
 * @param processIdentifier the unique identifier for for a {@link org.teiid.adminapi.ProcessObject ProcessObject}
 * in the system or "{@link org.teiid.adminapi.AdminObject#DELIMITER DELIMITER}"
 * if all Processes are desired.
 * @return Collection of {@link org.teiid.adminapi.ProcessObject ProcessObject}
 * @throws AdminException if there's a system error.
 * @since 4.3
 */
Collection getProcesses(String processIdentifier) {
    checkAdmin();
    result =internalAdmin.getProcesses(processIdentifier);
    debug(result);
    return result;
}



//*********************************************************************************************
// Runtime Methods
//
//*********************************************************************************************


/**
 * Start Connector Binding
 *
 * @param deployedName 
 * @throws AdminException  if there's a system error.
 */
void startConnectorBinding(String deployedName) {
    debug("Starting Connector Binding " + deployedName);
    checkAdmin();
    internalAdmin.startConnectorBinding(deployedName);
}

/**
 * Stop Connector Binding
 *
 * @param deployedName  identifier for {@link org.teiid.adminapi.ConnectorBinding}
 */
void stopConnectorBinding(String deployedName) {
    debug("Stoping Connector Binding " + deployedName);
    checkAdmin();
    internalAdmin.stopConnectorBinding(deployedName, true);
}

/**
 * Clear the cache or caches specified by the cacheIdentifier.
 * @param cacheType Cache Type
 * No wild cards currently supported, must be explicit
 * @throws AdminException  if there's a system error.
 */
void clearCache(String cacheType) {
	debug("Clearing cache type " + cacheType);
    checkAdmin();
    internalAdmin.clearCache(cacheType);
}

/**
 * Terminate the Session
 *
 * @param identifier  Session Identifier {@link org.teiid.adminapi.Session}.
 * No wild cards currently supported, must be explicit
 * @throws AdminException  if there's a system error.
 */
void terminateSession(long sessionId) {
    debug("Terminating Session " + sessionId);
    checkAdmin();
    internalAdmin.terminateSession(sessionId);
}

/**
 * Cancel Request
 *
 * @param sessionId session Identifier for the request.
 * @param requestId request Identifier
 * 
 * @throws AdminException  if there's a system error.
 */
void cancelRequest(long sessionId, long requestId) {
    debug("Canceling Request Session=" + sessionId + " request id = "+requestId);
    checkAdmin();
    internalAdmin.cancelRequest(sessionId, requestId);
}

/**
 * Stop the Teiid.  If millisToWait is >0, then close to incoming queries, wait the time period
 * for work to stop, then stop the MM Query.  Otherwise, stop immediately, aborting all running queries.
 * @param millisToWait Milliseconds to wait (if >0) or <=0 for no wait before stopping
 * @throws AdminException
 */
void shutdown(int millisToWait) {
    checkAdmin();
    internalAdmin.shutdown(millisToWait);	
    disconnect();
}

/**
 * Restart System
 * @throws AdminException if there's a system error.
 */
void restart() {
    checkAdmin();
   	internalAdmin.restart();	
    disconnect();
}



//*********************************************************************************************
// Utility Methods
//
//*********************************************************************************************


/**
 * Checks to make sure the given VDB exists in the system
 * @param vdbName - name of the VDB
 * @return boolean - true if exists; false otherwise
 */
boolean hasVDB(String vdbName) {
    checkAdmin();    
    Collection vdbs = internalAdmin.getVDBs();
    for (VDB vdb:vdbs) {
        if (vdb.getName().equals(vdbName)) {
            debug(true);
            return true;
        }
    }
    debug(false);    
    return false;
}

/**
 * Checks to make sure the given VDB with version exists in the system
 * @param vdbName - name of the VDB
 * @param version - version of the VDB
 * @return boolean - true if exists; false otherwise
 */
boolean hasVDB(String vdbName, int version) {
    checkAdmin();    
    Collection vdbs = internalAdmin.getVDBs();
    for (VDB vdb:vdbs) {
        if (vdb.getName().equals(vdbName) && vdb.getVDBVersion().equals(version)) {
            debug(true);
            return true;
        }
    }
    debug(false);
    return false;
}

/**
 * Checks to make sure the given binging exists.
 * @param bindingName - Name of the Binding.
 * @return boolean - true if exists; false otherwise
 */
boolean hasBinding(String bindingName) {
    checkAdmin();
    Collection bindings = internalAdmin.getConnectorBindings();
    
    for (ConnectorBinding binding:bindings) {
        if (binding.getName().equals(bindingName)) {
            debug(true);
            return true;
        }        
    }            
    debug(false);
    return false;
}

/**
 * Checks if given Connector Type exists in system
 * @param typeName - Binding type name
 * @return boolean - true if exists; false otherwise
 */
boolean hasConnectorType(String typeName) {
    checkAdmin();
    Collection types = internalAdmin.getConnectorTypes();

    for (ConnectorType type:types) {
        if (type.getName().equals(typeName)) {
            debug(true);
            return true;
        }
    }
    debug(false);
    return false;
}
