import org.teiid.adminapi.*;

import com.metamatrix.core.util.ObjectConverterUtil;


currentContext().internalVerbose = true;

/**
 * Deploy a {@link VDB} file.
 * @param vdbFile - VDB File Name
 * @throws AdminException
 * @return the {@link VDB} representing the current property values and runtime state.
 */
VDB deployVDB(String vdbFile) {
    debug("Adding VDB " + name + " from " + vdbFile);
    checkAdmin();    
    return internalAdmin.deployVDB(vdbFile, new FileInputStream(new File(vdbFile)));
}

/**
 * Delete the VDB with the given name and version
 * @param name - name of VDB
 * @param version - version of the VDB
 * @throws AdminException
 */
void deleteVDB(String name, int version) {
    checkAdmin();
    internalAdmin.deleteVDB(name, version);
}

/**
 * Export VDB to byte array
 *
 * @param vdbName identifier of the {@link VDB}
 * @param vdbVersion {@link VDB} version
 * @param fileName - File name to save the VDB
 * @throws AdminException
 */
void exportVDB(String vdbName, int vdbVersion, String fileName){
    debug("Exporting VDB " + vdbName + " version " + vdbVersion + " to file " + fileName);
    checkAdmin();
    contents = internalAdmin.exportVDB(vdbName, vdbVersion);
    if (contents != null) {
    	ObjectConverterUtil.write(contents, fileName);
    }
    else {
    	throw new AdminProcessingException("VDB with name "+ name + " is not found to export");
    }
}

/**
 * Deploy a {@link ConnectionFactory} to Configuration
 *
 * @param deployedName  Connection Factory name that will be added to Configuration
 * @param typeName Connector type name. 
 * @param properties Name & Value pair need to deploy the Connection Factory

 * @throws AdminException 
 */
void addConnectionFactory(String deployedName, String typeName, Properties properties) {
    debug("Adding Connection Factory " + deployedName);
    checkAdmin();    
    return internalAdmin.addConnectionFactory(deployedName, typeName, properties);
}

/**
 * Delete the {@link ConnectionFactory} from the Configuration
 *
 * @param deployedName - deployed name of the connection factory
 * @throws AdminException  
 */
void deleteConnectionFactory(String deployedName) throws AdminException {
    debug("Deleting Connection Factory " + deployedName);
    checkAdmin();    
    internalAdmin.deleteConnectionFactory(deployedName);
}

/**
 * Export a {@link ConnectionFactory} to character Array in XML format
 *
 * @param deployedName the unique identifier for a {@link ConnectionFactory}.
 * @param fileName - Name under which exported content stored under
 * @throws AdminException
 */
void exportConnectionFactory(String deployedName, String fileName){
    debug("Exporting Connection Factory " + deployedName + " to file " + fileName);
    checkAdmin();
    contents = internalAdmin.exportConnectionFactory(deployedName);
    if (contents != null) {
    	ObjectConverterUtil.write(contents, fileName);	
    }
    else {
    	throw new AdminProcessingException("Connector Binding "+ bindingName + " not found for exporting");
    }
}

/**
 * Assign a {@link ConnectionFactory} to a {@link VDB}'s Model
 *
 * @param vdbName Name of the VDB
 * @param vdbVersion Version of the VDB
 * @param modelName  Name of the Model to map Connection Factory
 * @param sourceName sourceName for the model
 * @param jndiName JNDI names to which the source name needs to map to
 * @throws AdminException
 */
void assignConnectionFactoryToModel(String vdbName, int vdbVersion, String modelName, String sourceName, String jndiName) throws AdminException{
    debug("Assigning Connection Factory,  source name:" + sourceName +" to JNDI resource: "+jndiName+ " for Model " + modelName + " in VDB " + vdbName + " version " + vdbVersion);
    checkAdmin();
    internalAdmin.assignConnectionFactoryToModel(vdbName, vdbVersion, modelName, sourceName, jndiName);
}


/**
 * Adds JDBC XA Data Source in the container.
 * @param dsName - name of the source
 * @param properties - properties
 * @throws AdminException
 */
void addDataSource(String dsName, Properties properties) {
    debug("Adding Datasource " + dsName);
    checkAdmin();    
    return internalAdmin.addDataSource(dsName, properties);	
}

/**
 * Delete data source. 
 * @param dsName
 * @throws AdminException
 */
void deleteDataSource(String dsName) {
    debug("Deleting Datasource " + dsName);
    checkAdmin();    
    return internalAdmin.deleteDataSource(dsName);	
}


/**
 * Get the property definitions for creating the JDBC data source.
 * @return
 * @throws AdminException
 */
Collection getDataSourcePropertyDefinitions(){
    debug("Datasource properties");
    checkAdmin();    
    return internalAdmin.getDataSourcePropertyDefinitions();		
}

/**
 * Add Connector Type, will import Connector Type from a file
 *
 * @param name  of the Connector to add
 * @param rarFile RAR file to be added
 * @throws AdminException
 */
void addConnector(String name, String rarFile) {
    debug("Adding Connector " + name + " from " + rarFile);
    checkAdmin();    
    internalAdmin.addConnector(name, new FileInputStream(new File(rarFile)));
}


/**
 * Delete Connector Type from Next Configuration
 *
 * @param name String name of the Connector to delete
 * @throws AdminException
 */
void deleteConnector(String name){
    debug("Deleting Connector " + name);
    checkAdmin();    
    internalAdmin.deleteConnector(name);
}

/**
 * Export Connector RAR file
 *
 * @param name  of the Connector
 * @return fileName - File name to be saved under 
 * @throws AdminException 
 */
void exportConnector(String name, String fileName) {
    debug("Exporting Connector Type " + name + " to file " + fileName);
    checkAdmin();
    
    contents = internalAdmin.exportConnector(name);
    if (contents != null) {
    	ObjectConverterUtil.write(contents, fileName);
    }
    else {
    	throw new AdminProcessingException("Connector type with name "+ name + " is not found to export");
    }
}


/**
 * Get all transaction matching the identifier.
 * @return
 * @throws AdminException
 */
Collection getTransactions() {
    checkAdmin();
    result = internalAdmin.getTransactions();
    debug(result);
    return result;	
}

/**
 * Mark the given global transaction as rollback only.
 * @param transactionId
 * @throws AdminException
 */
void terminateTransaction(String transactionId) {
    debug("Terminating transaction = " + transactionId);
    checkAdmin();    
    internalAdmin.terminateTransaction(transactionId);	
}

/**
 * Set/update the property for the Connection Factory identified by the given deployed name.
 * @param deployedName
 * @param propertyName
 * @param propertyValue
 * @throws AdminException
 */
void setConnectionFactoryProperty(String deployedName, String propertyName, String propertyValue) {
    debug("Setting property for Connection Factory: "+deployedName+" with property="+propertyName+" value="+propertyValue);
    checkAdmin();    
    internalAdmin.setConnectionFactoryProperty(deployedName, propertyName, propertyValue);    
}

// *********************************************************************************************
//  Monitor Methods
//
// *********************************************************************************************

/**
 * Get the Connectors  available in the configuration.
 *
 * @return Set of connector names.
 * @throws AdminException 
 */
Set getConnectorNames() {
    checkAdmin();
    result = internalAdmin.getConnectorNames();
    debug(result);
    return result;
}

/**
 * Get the VDBs that currently deployed in the system
 *
 * @return Collection of {@link VDB}s.  There could be multiple VDBs with the
 * same name in the Collection but they will differ by VDB version.
 * @throws AdminException if there's a system error.
 */
Set getVDBs() {
    checkAdmin();
    result = internalAdmin.getVDBs();
    debug(result);
    return result;
}

/**
 * Get the VDB
 * @param vdbName
 * @param vbdVersion
 * @throws AdminException if there's a system error.
 * @return
 */
VDB getVDB(String vdbName, int version) {
    checkAdmin();
    result = internalAdmin.getVDB(vdbName, version);
    debug(result);
    return result;
}

/**
 * Get all the Connection Factories for the given VDB identifier pattern
 * @param vdbName - Name of the VDB
 * @param vdbVersion - version of the VDB
 * @return Collection of {@link ConnectionFactory}
 * @throws AdminException 
 */
Collection getConnectionFactoriesInVDB(String vdbName, int vdbVersion) {
    checkAdmin();
    result = internalAdmin.getConnectionFactoriesInVDB(vdbName, vdbVersion);
    debug(result);
    return result;
}

/**
 * Get the Connection Factories that are available in the configuration
 *
 * @return Collection of {@link ConnectionFactory}
 * @throws AdminException 
 */
Collection getConnectionFactories() {
    checkAdmin();
    result = internalAdmin.getConnectionFactories();
    debug(result);
    return result;
}


/**
 * Get the Connection Factory by the given the deployed name.
 * @param deployedName - name of the deployed Connection Factory
 * @return null if not found a Connection Factory by the given name
 * @throws AdminException 
 */
ConnectionFactory getConnectionFactory(String deployedName) {
    checkAdmin();
    result = internalAdmin.getConnectionFactory(deployedName);
    debug(result);
    return result;	
}

/**
 * Get the Work Manager stats that correspond to the specified identifier pattern.
 *
 * @param identifier - an identifier for the queues {@link QueueWorkerPool}. "runtime" will return the stats for Query 
 * runtime Worker Pool. Also any Connector Binding name will return the stats for that connector binding.
 * @return Collection of {@link QueueWorkerPool}
 * @throws AdminException if there's a system error.
 */
WorkerPoolStatistics getWorkManagerStats(String identifier) {
    checkAdmin();
    result =internalAdmin.getWorkManagerStats(identifier);
    debug(result);
    return result;
}

/**
 * Get the Connection Pool Stats that correspond to the specified identifier pattern.
 * If the {@link ConnectionPoolStatistics ConnectionPool} represents an XA connection, there
 * will be 2 {@link ConnectionPoolStatistics ConnectionPool}s.  
 *
 * @param deployedName - an identifier that corresponds to the connection factory Name
 * @return {@link ConnectionPoolStatistics}
 * @throws AdminException if there's a system error.
 */
ConnectionPoolStatistics getConnectionFactoryStats(String deployedName) {
    checkAdmin();
    result =internalAdmin.getConnectionFactoryStats(deployedName);
    debug(result);
    return result;	
}

/**
 * Get the Caches that correspond to the specified identifier pattern
 * @return Collection of {@link String}
 * @throws AdminException if there's a system error.
 */
Collection getCacheTypes() {
    checkAdmin();
    result =internalAdmin.getCacheTypes();
    debug(result);
    return result;
}

/**
 * Get all the current Sessions.
 * @return Collection of {@link Session}
 * @throws AdminException if there's a system error.
 */
Collection getSessions() {
    checkAdmin();
    result =internalAdmin.getSessions();
    debug(result);
    return result;
}

/**
 * Get the all Requests that are currently in process
 * @return Collection of {@link Request}
 * @throws AdminException if there's a system error.
 */
Collection getRequests() {
    checkAdmin();
    result =internalAdmin.getRequests();
    debug(result);
    return result;
}

/**
 * Get the Requests for the given session
 * @param sessionId - session id 
 * @return Collection of {@link Request}
 * @throws AdminException if there's a system error.
 */
Collection getRequestsForSession(long sessionId){
    checkAdmin();
    result =internalAdmin.getRequestsForSession(sessionId);
    debug(result);
    return result;	
}

/**
 * Get all of the available Configuration Properties for the specified connector
 * @param connectorName - Name of the connector
 * @return set of property definitions
 * @throws AdminException
 */
Collection getConnectorPropertyDefinitions(String connectorName){
	checkAdmin();
    result = internalAdmin.getConnectorPropertyDefinitions(connectorName);
    debug(result);
    return result;	
}

/**
 * Get the processes that correspond to the specified identifier pattern.
 *
 * @param processIdentifier the unique identifier for for a {@link org.teiid.adminapi.ProcessObject ProcessObject}
 * in the system or "{@link org.teiid.adminapi.AdminObject#DELIMITER DELIMITER}"
 * if all Processes are desired.
 * @return Collection of {@link org.teiid.adminapi.ProcessObject ProcessObject}
 * @throws AdminException if there's a system error.
 * @since 4.3
 */
Collection getProcesses(String processIdentifier) {
    checkAdmin();
    result =internalAdmin.getProcesses(processIdentifier);
    debug(result);
    return result;
}



//*********************************************************************************************
// Runtime Methods
//
//*********************************************************************************************


/**
 * Start Connection Factory
 *
 * @param deployedName 
 * @throws AdminException  
 */
void startConnectionFactory(String deployedName) {
    debug("Starting Connection Factory " + deployedName);
    checkAdmin();
    internalAdmin.startConnectionFactory(deployedName);
}

/**
 * Stop Connection Factory
 *
 * @param deployedName
 * @throws AdminException  
 */
void stopConnectionFactory(String deployedName) {
    debug("Stoping Connection Factory " + deployedName);
    checkAdmin();
    internalAdmin.stopConnectionFactory(deployedName, true);
}

/**
 * Clear the cache or caches specified by the cacheIdentifier.
 * @param cacheType Cache Type
 * No wild cards currently supported, must be explicit
 * @throws AdminException  if there's a system error.
 */
void clearCache(String cacheType) {
	debug("Clearing cache type " + cacheType);
    checkAdmin();
    internalAdmin.clearCache(cacheType);
}

/**
 * Terminate the Session
 *
 * @param sessionId  Session Identifier {@link org.teiid.adminapi.Session}.
 * @throws AdminException
 */
void terminateSession(long sessionId) {
    debug("Terminating Session " + sessionId);
    checkAdmin();
    internalAdmin.terminateSession(sessionId);
}

/**
 * Cancel Request
 *
 * @param sessionId session Identifier for the request.
 * @param requestId request Identifier
 * @throws AdminException
 */
void cancelRequest(long sessionId, long requestId) {
    debug("Canceling Request Session=" + sessionId + " request id = "+requestId);
    checkAdmin();
    internalAdmin.cancelRequest(sessionId, requestId);
}


//*********************************************************************************************
// Utility Methods
//
//*********************************************************************************************


/**
 * Checks to make sure the given VDB exists in the system
 * @param vdbName - name of the VDB
 * @return boolean - true if exists; false otherwise
 */
boolean hasVDB(String vdbName) {
    checkAdmin();    
    Collection vdbs = internalAdmin.getVDBs();
    for (VDB vdb:vdbs) {
        if (vdb.getName().equals(vdbName)) {
            debug(true);
            return true;
        }
    }
    debug(false);    
    return false;
}

/**
 * Checks to make sure the given VDB with version exists in the system
 * @param vdbName - name of the VDB
 * @param version - version of the VDB
 * @return boolean - true if exists; false otherwise
 */
boolean hasVDB(String vdbName, int version) {
    checkAdmin();    
    Collection vdbs = internalAdmin.getVDBs();
    for (VDB vdb:vdbs) {
        if (vdb.getName().equals(vdbName) && vdb.getVDBVersion().equals(version)) {
            debug(true);
            return true;
        }
    }
    debug(false);
    return false;
}

/**
 * Checks to make sure the given connection factory exists.
 * @param factoryName - Name of the connection factory
 * @return boolean - true if exists; false otherwise
 */
boolean hasConnectionFactory(String factoryName) {
    checkAdmin();
    Collection bindings = internalAdmin.getConnectionFactories();
    
    for (ConnectionFactory binding:bindings) {
        if (binding.getName().equals(factoryName)) {
            debug(true);
            return true;
        }        
    }            
    debug(false);
    return false;
}

/**
 * Checks if given Connector exists in system
 * @param typeName - connector name
 * @return boolean - true if exists; false otherwise
 */
boolean hasConnector(String typeName) {
    checkAdmin();
    Collection types = internalAdmin.getConnectorNames();

    for (String type:types) {
        if (type.equals(typeName)) {
            debug(true);
            return true;
        }
    }
    debug(false);
    return false;
}
