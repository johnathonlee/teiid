/*
 * JBoss, Home of Professional Open Source.
 * Copyright (C) 2008 Red Hat, Inc.
 * Copyright (C) 2000-2007 MetaMatrix, Inc.
 * Licensed to Red Hat, Inc. under one or more contributor 
 * license agreements.  See the copyright.txt file in the
 * distribution for a full listing of individual contributors.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

package com.metamatrix.core.id;

import com.metamatrix.core.CorePlugin;
import com.metamatrix.internal.core.id.*;

/**
 * <p>This class is a factory for generating universally unique identifiers
 * (UUID's). </p>
 *
 * <h3>Output format for UUIDs</h3>
 * <p>UUIDs are output in the following 36-character format:
 * <pre>
 *    xxxxxxxx-yyyy-zzzz-cccc-nnnnnnnnnnnn
 * </pre>
 * where x=least significant time component, y=middle significant time component,
 * z=most significant time component multiplexed with version, c=clock sequence
 * multiplexed with variant, and n=node component (random number).
 * </p>
 *
 * <p>The generated ID's conform somewhat to the (now expired) IETF internet
 * draft standard, "UUIDs and GUIDs", DCE spec on UUIDs. </p>
 *
 * <ul>
 *   <li>
 *   <a href="http://hegel.ittc.ukans.edu/topics/internet/internet-drafts/draft-l/draft-leach-uuids-guids-01.txt">
 *      UUIDs and GUIDs, P. Leach, R. Salz, 02/05/1998</a>
 *   </li>
 *   <li>
 *   <a href="http://www.opengroup.org/onlinepubs/009629399/apdxa.htm">
 *      DCE Universal Unique Identifier</a>.
 *   </li>
 * </ul></p>
 *
 * <p>All references in this code to bit positions as "least significant" and
 * "most significant" refer to the bits moving from right to left, respectively.
 * </p>
 */
public class UUIDFactory implements ObjectIDFactory {
    
    public static boolean DEBUG_UUID_FACTORY = false;

    /**
     * The actual creation methods are delegated to a separate (embedded) factory for two primary
     * reasons.  First, the embedded factory is expensive to create and has a number of static
     * variables that are expensive and time-consuming to instantiate.  However, the UUIDFactory
     * cannot be time-consuming to create, so this class initializes the embedded factory in a 
     * separate thread so that instantiating a UUIDFactory doesn't take long.
     * Second, all UUIDFactory instances share this embedded factory.
     */
    private static EmbeddedUUIDFactory REAL_FACTORY;    // all UUIDFactory instances

    private static final Object LOCK = new Object();
    
    // -------------------------------------------------------------------------
    //                           C O N S T R U C T O R
    // -------------------------------------------------------------------------
    
    /**
     * <p>Construct an instance of this factory.  This constructor attempts 
     * to get an instance of a cryptographically strong pseudo-random number
     * generator {@link java.security.SecureRandom}, using the "SH1" algorithm.
     * If this fails, a message is logged and the standard random number
     * generator {@link java.util.Random} is used. </p>
     *
     * <p>This constructor also loads up a single random number to be used
     * for all ID's generated by this factory.  This random number is meant to
     * represent the "node" part of ID, which is supposed to cover the
     * spatial component of the generated ID's. </p>
     */
    public UUIDFactory() {
        initializeEmbeddedFactory();
    }
    
    // -------------------------------------------------------------------------
    //              I N I T I A L I Z A T I O N   M E T H O D S
    // -------------------------------------------------------------------------
    
    /**
     * Called by the constructor to kick off the initialization of the REAL_FACTORY, which may take several seconds
     */
    private final void initializeEmbeddedFactory() {
        if ( REAL_FACTORY == null ) {
            new Thread() {
                public void run() {
                    synchronized(LOCK) {
                        if ( REAL_FACTORY == null ) {
                            REAL_FACTORY = new EmbeddedUUIDFactory();
                       }
                    }
                    notifyMethod();
                }
            }.start();
        }
    }
    
    /**
     * This method is called by the create, essentially blocking if the REAL_FACTORY is null and the initializer
     * hasn't complete.
     */
    private synchronized void waitMethod() {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * This method is called by the initializer thread when completed.
     */
    private synchronized void notifyMethod() {
        // 
        notifyAll();
    }

    // -------------------------------------------------------------------------
    //                       P U B L I C     M E T H O D S
    // -------------------------------------------------------------------------
    
    /**
     * Return the description for the type of ObjectID described by this object.
     * @return the description
     */
    public String getDescription() {
        return CorePlugin.Util.getString("UUIDFactory.Description"); //$NON-NLS-1$
    }

    /**
     * <p>Return whether the specified ObjectID instance is valid.  Only ObjectID
     * instances that are for this protocol will be passed in. </p>
     * 
     * <p>This implementation defers the validation to the UUID class. </p>
     *
     * @param id the ID that is to be validated, and which is never null
     * @return true if the instance is valid for this protocol, or false if
     * it is not valid.
     */
    public boolean validate(ObjectID id) {
        if ( id instanceof UUID ) {
            return UUID.validate(id);
        }
        return false;
    }

    /**
     * Attempt to convert the specified string to the appropriate ObjectID instance.
     * This method is called by the {@link IDGenerator#stringToObject(String)} method, which
     * must process the protocol to determine the correct parser to use.  As such, it guarantees
     * that the parser that receives this call can assume that the protocol was equal to the
     * protocol returned by the parser's {@link ObjectIDDescriptor#getProtocol()}.
     * @param value the stringified id with the protocol and ObjectID.DELIMITER already
     * removed, and should never null or zero length
     * @return the ObjectID instance for the stringified ID if this factory is able
     * to parse the string, or null if the factory is unaware of the specified format.
     * @throws InvalidIDException if the parser is aware of this protocol, but it is of the wrong
     * format for this type of ObjectID.
     */
    public ObjectID stringWithoutProtocolToObject(String value) throws InvalidIDException {
        return UUID.stringToObject(value);
    }

    /**
     * Attempt to convert the specified string to the appropriate ObjectID instance.
     * @param value the stringified id (the result of {@link ObjectID#toString()}),
     * and should never null or zero length
     * @return the ObjectID instance for the stringified ID if this factory is able
     * to parse the string, or null if the factory is unaware of the specified format.
     * @throws InvalidIDException if the parser is aware of this protocol, but it is of the wrong
     * format for this type of ObjectID.
     */
    public ObjectID stringToObject(String value) throws InvalidIDException {
        final ParsedObjectID parsedID = ParsedObjectID.parsedStringifiedObjectID(value,UUID.PROTOCOL);
        return UUID.stringToObject(parsedID.getRemainder());
    }

    /**
     * Return the name of the protocol that this factory uses.
     * @return the protocol name
     */
    public String getProtocol() {
	    return UUID.PROTOCOL;
    }

    /** Return the number of ID's that this factory instance has generated. */
    long getCount() {
        synchronized(LOCK) {
            return REAL_FACTORY.getCount();
        }
    }

    // -------------------------------------------------------------------------
    //                   G E N E R A T I O N    M E T H O D S
    // -------------------------------------------------------------------------
    
    /**
     * <p>Create a new ObjectID instance using this protocol. </p>
     *
     * <p>This member must be synchronized because it makes use of shared
     * internal state. </p>
     *
     * <p>This algorithm follows the one specified in the IETF spec.  It uses
     * a pseudo-random number generated by a cryptographically string random
     * number generator for the "node" component, as recommended in Section 4
     * of that paper. </p>
     *
     * <h3>Algorithm from IETF spec</h3>
     * <p>
     * <ol>
     *    <li> Determine the values of the timestamp and clock sequence.  For
     *         the purposes of this algorithm, consider the timestamp to be a
     *         60-bit unsigned integer and the clock sequence to be a 14-bit
     *         unsigned integer. </li>
     *    <li> Adjust the clock sequence if time has "moved backward". </li>
     *    <li> Adjust the local system time to convert from millseconds
     *         to nanoseconds, and to account for multiple UUIDs per tick. </li>
     *    <li> Adjust the clock sequence if time has "moved backward". </li>
     *    <li> Put the time component (adjusted for locale and sclae) into
     *         the most significant part of the UUID, with the least significant
     *         part of time in the most significant part of the UUID. </li>
     *    <li> Multiplex the spec version into the most significant 4 bits of
     *         of the "high time" field </li>
     *    <li> Put the clock sequence number into the least significant 14 bits
     *         of the most significant 2 bytes (16 bits) of the least significant
     *         part of the UUID. </li>
     *    <li> Multiplex the variant into the most significant 2 bits of the
     *         clock sequence number bytes. </li>
     *    <li> Set the least significant 6 bytes of the least significant part
     *         of the UUID to the random number representing the "node".
     *         The highest bit of the node component should be '1'. </li>
     * </ol>
     * </p>
     *
     * <i>NOTE that we are *not* adjusting the time to conform exactly to the
     * IETF spec, where timestamp is relative to 15 Oct 1582 00:00:00.00 </i>
     * 
     * @return Universally unique ID (UUID)
     */
    public ObjectID create() {
        // If there is no factory yet (i.e., this method is called immediately after construction
        // and the initialization thread hasn't gotten it's lock yet ...
        if ( REAL_FACTORY == null ) {
            // then wait for the initialization to complete
            waitMethod();
        }
        synchronized(LOCK) {
            return REAL_FACTORY.create();
        }
    }

}

