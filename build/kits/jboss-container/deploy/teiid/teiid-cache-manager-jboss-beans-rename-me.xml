<?xml version="1.0" encoding="UTF-8"?>

    <!-- 
    If you are running JBoss AS in clustered mode, to enable the clustered cache in 
    the Teiid rename this file to "teiid-cache-manager-jboss-beans.xml"
    -->

<deployment xmlns="urn:jboss:bean-deployer:2.0">

    <!-- Factory/registry for JBoss Cache and PojoCache instances used in the AS -->
    <bean name="TeiidCacheManager" class="org.jboss.ha.cachemanager.CacheManager">
        <property name="jndiName">java:TeiidCacheManager</property>
        <property name="configurationRegistry">
            <inject bean="TeiidCacheConfigurationRegistry" />
        </property>
        <property name="channelFactory">
            <inject bean="JChannelFactory" />
        </property>

        <!-- Aliases for cache names. Allows caches to be shared across 
           services that may expect different cache config names. -->
        <property name="configAliases">
            <map keyClass="java.lang.String" valueClass="java.lang.String">
                <!-- Use the HAPartition cache for ClusteredSSO caching -->
                <entry>
                    <key>teiid-resultset-cache</key>
                    <value>teiid-resultset-cache</value>
                </entry>
            </map>
        </property>
    </bean>

    <!-- 
     | Registry of named JBoss Cache configurations. Users of the CacheManager
     | request a cache with a particular configuration by providing the name
     | of one of these configurations.
   -->
    <bean name="TeiidCacheConfigurationRegistry" class="org.jboss.ha.cachemanager.DependencyInjectedConfigurationRegistry">

        <!-- The configurations. A Map<String name, Configuration config> -->
        <property name="newConfigurations">
            <map keyClass="java.lang.String" valueClass="org.jboss.cache.config.Configuration">

                <!-- A config appropriate for a cache that's shared for
                     entity, collection, query and timestamp caching. Not an advised
                     configuration, since it requires cache mode REPL_SYNC, which is the 
                     least efficient mode. Also requires a full state transfer at startup,
                    which can be expensive. Uses mvcc locking. -->
                <entry>
                    <key>teiid-resultset-cache</key>
                    <value>
                        <bean class="org.jboss.cache.config.Configuration">

                            <!-- Node locking scheme -->
                            <property name="nodeLockingScheme">MVCC</property>
                            <!-- READ_COMMITTED is as strong as necessary for most 
                                2nd Level Cache use cases. -->
                            <property name="isolationLevel">READ_COMMITTED</property>
                            <property name="useLockStriping">false</property>

                            <!-- Must use REPL since used for timestamp caching. 
                                 Must use SYNC to maintain cache coherency for entities. -->
                            <property name="cacheMode">REPL_SYNC</property>

                            <!-- Name of cluster. Needs to be the same for all members -->
                            <property name="clusterName">${jboss.partition.name:DefaultPartition}-resultset-cache</property>
                            <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
                                because timestamp communication will not require a synchronous response. -->
                            <property name="multiplexerStack">${jboss.default.jgroups.stack:udp}</property>
                            <!-- Used for timestamps, so must fetch state. -->
                            <property name="fetchInMemoryState">true</property>

                            <!-- The max amount of time (in milliseconds) we wait until the
                                 state (ie. the contents of the cache) are retrieved from
                                 existing members at startup. Ignored if FetchInMemoryState=false. -->
                            <property name="stateRetrievalTimeout">60000</property>

                            <!-- Number of milliseconds to wait until all responses for a
                                 synchronous call have been received. -->
                            <property name="syncReplTimeout">17500</property>

                            <!-- Max number of milliseconds to wait for a lock acquisition -->
                            <property name="lockAcquisitionTimeout">15000</property>

                            <!-- Hibernate 2LC can replicate custom types, so we use marshalling -->
                            <property name="useRegionBasedMarshalling">true</property>
                            <!-- Must match the value of "useRegionBasedMarshalling" -->
                            <property name="inactiveOnStartup">false</property>

                            <!-- Disable asynchronous RPC marshalling/sending -->
                            <property name="serializationExecutorPoolSize">0</property>
                            <!-- We have no asynchronous notification listeners -->
                            <property name="listenerAsyncPoolSize">0</property>

                            <property name="evictionConfig">
                                <bean class="org.jboss.cache.config.EvictionConfig">
                                    <property name="wakeupInterval">5000</property>
                                    <!--  Overall default -->
                                    <property name="defaultEvictionRegionConfig">
                                        <bean class="org.jboss.cache.config.EvictionRegionConfig">
                                            <property name="regionName">/</property>
                                            <property name="evictionAlgorithmConfig">
                                                <bean class="org.jboss.cache.eviction.LRUAlgorithmConfig">
                                                    <!-- Evict LRU node once we have more than this number of nodes -->
                                                    <property name="maxNodes">10000</property>
                                                    <!-- And, evict any node that hasn't been accessed in this many seconds -->
                                                    <property name="timeToLiveSeconds">1000</property>
                                                    <!-- Don't evict a node that's been accessed within this many seconds. 
                                                        Set this to a value greater than your max expected transaction length. -->
                                                    <property name="minTimeToLiveSeconds">120</property>
                                                </bean>
                                            </property>
                                        </bean>
                                    </property>
                                </bean>
                            </property>
                            <property name="cacheLoaderConfig">
                                <bean class="org.jboss.cache.config.CacheLoaderConfig">
                                    <!-- Do not change these -->
                                    <property name="passivation">false</property>
                                    <property name="shared">false</property>

                                    <property name="individualCacheLoaderConfigs">
                                        <list>
                                            <bean class="org.teiid.cache.jboss.TupleBatchCacheLoaderConfig">
                                                <property name="bufferService"><inject bean="BufferService" /></property>
                                                <property name="ignoreModifications">true</property>
                                                <property name="timeout">10000</property>
                                            </bean>
                                        </list>
                                    </property>
                                </bean>
                            </property>
                        </bean>
                    </value>
                </entry>
            </map>
        </property>
    </bean>
    
    <bean name="EventDistributorFactory" class="org.teiid.events.jboss.JGroupsEventDistributor">
    	<property name="jndiName">teiid/event-distributor</property>
        <property name="channelFactory">
            <inject bean="JChannelFactory" />
        </property>
        <property name="clusterName">${jboss.partition.name:DefaultPartition}-teiid-events</property>
        <property name="multiplexerStack">${jboss.default.jgroups.stack:udp}</property>        
        <property name="localEventDistributorName">teiid/engine-deployer</property>
    </bean>

</deployment>