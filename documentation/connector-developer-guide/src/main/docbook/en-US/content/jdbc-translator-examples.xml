<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="examples">
  <title>JDBC Extension Examples</title>
  <para>This chapter contains a series of examples showing how to extend the JDBC Connector for different common scenarios.  </para>
  <sect1>
    <title>Adding Support for a Scalar Function</title>
    <sect2>
      <title>Overview</title>
      <para>For this example we consider how a translator might provide support for accepting 
      a function supported by Teiid.  See the following section for adding support for a new 
      function unknown to Teiid.  This example will show you how to declare support for the function 
      and modify how the function is passed to the data source.</para>
      <para>Following is a summary of all the steps in supporting a new scalar function:</para>
      <orderedlist>
          <listitem>
            <para>Override the capabilities method to declare support for the function  (REQUIRED)</para>
          </listitem>
          <listitem>
            <para>Implement a FunctionModifier to change how a function is translated  (OPTIONAL)</para>
          </listitem>
          <listitem>
            <para>Implement a SQLTranslator extension and register the new function modifier  (OPTIONAL)</para>
          </listitem>
      </orderedlist>      
      <para>The capabilities class has a method getSupportedFunctions() that declares all the scalar functions that can be supported by the connector.  To add support for a new function, extend an existing capabilities class (like the base JDBC class JDBCCapabilities or the provided base class in the Connector API, BasicConnectorCapabilities). </para>
      <para>Below is an example of an extended capabilities class to add support for the “abs” absolute value function:</para>
        <programlisting><![CDATA[
            package my.connector;
            
            import java.util.ArrayList;
            import java.util.List;
            
            public class ExtendedJDBCExecutionFactory extends JDBCExecutionFactory {
                @Override
                public List getSupportedFunctions() {
                    List supportedFunctions = new ArrayList();
                    supportedFunctions.addAll(super.getSupportedFunctions());
                    supportedFunctions.add("ABS"); 
                    return supportedFunctions;
                }
            }          
          ]]></programlisting>      
          <para>In general, it is a good idea to call super.getSupportedFunctions() to ensure that you retain any function 
          support provided by the translator you are extending.</para>
          <para>This may be all that is needed to support a Teiid function if the JDBC data source supports the 
          same syntax as Teiid.  The built-in SQL translation will translate most functions as: “function(arg1, arg2, …)”.</para>       
    </sect2>
    <sect2>
      <title>Using FunctionModifiers</title>
      <para>In some cases you may need to translate the function differently or even insert 
      additional function calls above or below the function being translated.  The JDBC translator provides 
      an abstract class <emphasis>FunctionModifier</emphasis>  can be used to register function 
      translations in a SQLTranslator extension.  </para>
      
      <para>The FunctionModifier has method called "translate".  Generally, it is recommended 
      to subclass FunctionModifier and override the method.
      Use the translate method to change the way the function is represented; 
      this is typically only necessary when using a non-standard function form with special operators or 
      ways of representing parameters. </para>
      
      <para>Below is an example of overriding just the translate method to translate the MOD(a, b) function into an operator form for Sybase (a % b).  The translate method returns a list of strings and language objects that will be assembled by the translator into a final string.  The strings will be used as is and the language objects will be further processed by the translator.</para>
      
      <programlisting><![CDATA[
          
          public class ModFunctionModifier implements FunctionModifier {
          
              public List translate(Function function) {
                  List parts = new ArrayList();
                  parts.add("(");        
                  Expression[] args = function.getParameters();
                  parts.add(args[0]);
                  parts.add(" % "); 
                  parts.add(args[1]);
                  parts.add(")");    
                  return parts;
              }
          }      
      ]]></programlisting> 
            
      <para>You can also extend the <emphasis>AliasModifier</emphasis> that defines a method called "modify"
      using which you can modify in coming function from Teiid server into some thing that is source specific.</para>
      
      <para>Below is an example of using a AliasFunctionModifier to modify the incoming function.  This particular 
      example is from the Oracle JDBC Translator and is translating the Teiid function HOUR(ts) which takes a  
      timestamp and returns the hour part into the Oracle equivalent TO_NUMBER(TO_CHAR(ts, ‘HH24’)).  
      It demonstrates the use of the LanguageFactory to construct new functions and literal values.</para>
      <programlisting><![CDATA[          
          /**
           * Convert the HOUR function into an equivalent Oracle function.  
           * HOUR(ts) --> TO_NUMBER(TO_CHAR(ts, 'HH24'))
           */
          public class HourFunctionModifier extends AliasFunctionModifier {
          
              private LanguageFactory langFactory;
              
              public HourFunctionModifier(LanguageFactory langFactory) {
                  this.langFactory = langFactory;
              }
              
              public Expression modify(Function function) {
                  Expression[] args = function.getParameters();
              
                  Function innerFunction = langFactory.createFunction("TO_CHAR",  
                      new Expression[] { 
                          args[0],
                          langFactory.createLiteral("HH24", String.class)},  String.class); 
          
                  Function outerFunction = langFactory.createFunction("TO_NUMBER",  
                      new Expression[] { innerFunction },Integer.class); 
                      
                  return outerFunction;
              }
          }      
      ]]></programlisting>  
      
      <para>In addition to building your own FunctionModifiers, there are a number of pre-built generic 
      function modifiers that are provided with the translator.  </para>
      
      <table frame='all'>
        <title>Connection Factories</title>
        <tgroup cols='2' align='left' colsep='1' rowsep='1'>
          <colspec colname='c1' colwidth="1*"/>
          <colspec colname='c2' colwidth=".5*"/>
          <thead>      
            <row>
              <entry><para>Modifier</para></entry>
              <entry><para>Description</para></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><para>AliasModifier</para></entry>
              <entry><para>Handles simply renaming a function (“ucase” to “upper” for example)</para></entry>
            </row>
            <row>
              <entry><para>DropFunctionModifier</para></entry>
              <entry><para>Replaces a function with the function’s first argument, effectively dropping the function call if it is unnecessary – useful with unneeded type conversions</para></entry>
            </row>
            <row>
              <entry><para>EscapeSyntaxModifier</para></entry>
              <entry><para>Wraps a function in the standard JDBC escape syntax for functions: {fn xxxx()}</para></entry>
            </row>            
          </tbody>
        </tgroup>
      </table>
      <para>To register the function modifiers for your supported functions, 
      you must implement call " public void registerFunctionModifier(String name, FunctionModifier modifier)" method.
       Below is an example that registers some functions.</para>
      <programlisting><![CDATA[
          
          public class ExtendedJDBCExecutionFactory extends JDBCExecutionFactory
              
              @Override
              public void start() {
                  super.start();
                  
                  // register functions.
                  registerFunctionModifier("abs", new MyAbsModifier()); 
                  registerFunctionModifier("concat", new AliasModifier(“concat2”)); 
              }
          }        
      ]]></programlisting>  
      <para>Support for the two functions being registered (“abs” and “concat”) must be declared 
      in the capabilities as well.  Functions that do not have modifiers registered will be translated as usual.  
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Pushdown Scalar Functions</title>
    <para>“Pushdown” scalar functions are special in that they are functions new to Teiid that can be “pushed down” 
    to the translator.  Implementing support for a pushdown scalar function is identical to implementing support 
    for a standard Teiid function except that the function must be declared to Teiid as such.  This allows 
    Teiid to properly parse and resolve queries using the pushdown function.</para>
    <para>Pushdown scalar functions are modeled as user-defined functions with a special attribute.  
    They differ from normal user-defined functions in that no code is provided and the 
    Teiid engine does not how to execute the function.  Pushdown functions typically must be passed 
    to the translator for evaluation.  User-defined scalar functions have a special pushdown attribute that should be 
    set to “Required” when modeling a pushdown function.  </para>
    <para>For more information on modeling user-defined scalar functions, see the Reference manual.</para>    
  </sect1>
  
</chapter>