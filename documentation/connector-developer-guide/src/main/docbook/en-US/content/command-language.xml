<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../../../../../../docbook/custom.dtd">
%CustomDTD;
]>
<chapter id="command_language">
  <title>Command Language</title>
  
  <sect1>
    <title>Language Interfaces</title>
	<para>
		Teiid sends commands to your connector in object form. The interfaces
		for these objects are all defined in the org.teiid.connector.language
		package. These interfaces can be combined to represent any possible
		command that Teiid may send to the connector. However, it is possible
		to notify Teiid that your connector can only accept certain kinds of
		commands via the ConnectorCapabilities class. See the section on using
		<link linkend="connector_capabilities">Connector Capabilities</link>
		for more information.
	</para>
	<para>The language interfaces all extend from the ILanguageObject interface.
		Language objects should be thought of as a tree where each node is a
		language object that has zero or more child language objects of types
		that are dependent on the current node.</para>
	<para>All commands sent to your connector are in the form of these
		language trees, where the root of the tree is a subclass of ICommand.
		ICommand has several sub-interfaces, namely: IQueryCommand, IInsert, IUpdate,
		IDelete, IBatchedUpdate, and IProcedure.  
		Important components of
		these commands are expressions, criteria, and
		joins, which are examined
		in closer detail below. Also see the
		<ulink url="&javaDocUrl;">Teiid JavaDocs</ulink>
		for more on the classes and interfaces described here.
	</para>
    <sect2>
      <title>Expressions</title>
		<para>An expression represents a single value in context, although in
			some cases that value may change as the query is evaluated.  For
			example, a literal value, such as 5 represents an integer value.  An
			element reference such as "table.EmployeeName" represents a column in a data source
			and may logically take on many values while the command is being
			evaluated.</para>
      <itemizedlist>
	<listitem>
		<para>
			<code>IExpression</code>
			– base expression interface
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IElement</code>
			– represents an element in the data source
		</para>
	</listitem>
	<listitem>
		<para>
			<code>ILiteral</code>
			– represents a literal scalar value, but may also be multi-valued in
			the case of bulk updates.
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IFunction</code>
			– represents a scalar function with parameters that are also
			IExpressions
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IAggregate</code>
			– represents an aggregate function which holds a single expression
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IScalarSubquery</code>
			– represents a subquery that returns a single value
		</para>
	</listitem>
	<listitem>
		<para>
			<code>ISearchedCaseExpression</code>
			– represents a searched CASE expression.  The searched CASE
			expression evaluates the criteria in WHEN clauses till one evaluates
			to TRUE, then evaluates the associated THEN clause.
		</para>
	</listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Criteria</title>
		<para>A criteria is a combination of expressions and operators that
			evaluates to true, false, or unknown.  Criteria are most commonly used in the
			WHERE or HAVING clauses.</para>
      
      <itemizedlist>
        <listitem><para><code>ICriteria</code> – the base criteria interface</para></listitem>
        <listitem><para><code>ILogicalCriteria</code> – used to logically combine other criteria</para></listitem>
        <listitem><para><code>INotCriteria</code> – used to NOT another criteria</para></listitem>
        <listitem><para><code>ICompoundCriteria</code> – used to combine other criteria via AND or OR</para></listitem>
        <listitem><para><code>IPredicateCriteria</code> – a predicate that evaluates to true, false, or unknown</para></listitem>
        <listitem><para><code>ISubuqeryCompareCriteria</code> – represents a comparison criteria with a subquery including a quantifier such as SOME or ALL</para></listitem>
        <listitem><para><code>ICompareCriteria</code> – represents a comparison criteria with =, &gt;, &lt;, etc.</para></listitem>
        <listitem><para><code>IBaseInCriteria</code> – base class for an IN criteria</para></listitem>
        <listitem><para><code>IInCriteria</code> – represents an IN criteria that has a set of expressions for values</para></listitem>
        <listitem><para><code>ISubqueryInCriteria</code> – represents an IN criteria that uses a subquery to produce the value set</para></listitem>
        <listitem><para><code>IIsNullCriteria</code> – represents an IS NULL criteria</para></listitem>
        <listitem><para><code>IExistsCriteria</code> – represents an EXISTS criteria that determines whether a subquery will return any values</para></listitem>
        <listitem><para><code>ILikeCriteria</code> – represents a LIKE criteria that compares string values</para></listitem>
      </itemizedlist>                  
    </sect2>
    
    <sect2>
      <title>The FROM Clause</title>
		<para>The FROM clause contains a list of IFromItems.  Each IFomItem can
			either represent a group or a join between two other IFromItems.  This
			allows joins to be composed into a join tree.</para>
      
      <itemizedlist>
        <listitem><para><code>IGroup</code> – represents a single group</para></listitem>
        <listitem><para><code>IJoin</code> – has a left and right <code>IFromItem</code> and information on the join between the items</para></listitem>
        <listitem><para><code>IInlineView</code> – represents a group defined by an inline <code>IQueryCommand</code></para></listitem>
      </itemizedlist>
		<para>A list of IFromItems is used by default in the pushdown query
			when no outer joins are used. If an outer join is used anywhere in the
			join tree, there will be a tree of IJoins with a single root. This latter form
			is the ANSI perfered style. If you wish all pushdown queries
			containing joins to be in ANSI style have the
			ConnectorCapability.useAnsiJoin return true.  See <link linkend="command_form_capabilities">Command Form Capabilities</link> for more.</para>
    </sect2>
	<sect2>
		<title>IQueryCommand Structure</title>
		<para>IQueryCommand (refered to in SQL as a Query Expression) is the base for both queries and set queries.  It may optionally take an IOrderBy (representing a SQL ORDER BY clause) and a ILimit (represent a SQL LIMIT clause)</para>
	</sect2>
    <sect2>
      <title>IQuery Structure</title>

		<para>Each IQuery will have an ISelect describing the expressions
			(typically elements) being selected and an IFrom specifying the group
			or groups being selected from, along with any join information.  The
			IQuery may optionally also supply an ICriteria (representing a SQL
			WHERE clause), an IGroupBy (representing a SQL GROUP BY clause), an
			an ICriteria (representing a SQL HAVING clause).</para>            
    </sect2>      

    <sect2>
      <title>ISetQuery Structure</title>

		<para>An ISetQuery represents on of the SQL set operations (UNION,
			INTERSECT, EXCEPT) on two IQueryCommands. The all flag may be set to
			indicate UNION ALL (currently INTERSECT and EXCEPT ALL are not allowed
			in Teiid)</para>
    </sect2>
        
    <sect2>    
      <title>IInsert Structure</title>

		<para>Each IInsert will have a single IGroup specifying the group being
			inserted into.  It will also a list of
			IElements specifying the columns of the IGroup that are being inserted
			into and an IInsertValueSource, which will either be a list of IExpression (IInsertExpressionValueSource) or an IQueryCommand.</para>
    </sect2>

    <sect2>
      <title>IUpdate Structure</title>

		<para>Each IUpdate will have a single IGroup specifying the group being
			updated.  The ISetClauseList contains ISetClause entries that specify
			IElement and IExpression pairs for the update.
			The IUpdate may optionally provide a
			criteria specifying which rows should be updated.</para>
    </sect2>

    <sect2>
      <title>IDelete Structure</title>

		<para>Each IDelete will have a single IGroup specifying the group being
			deleted from. It may also optionally have a criteria specifying which
			rows should be deleted.  </para>
    </sect2>

    <sect2>
      <title>IProcedure Structure</title>

		<para>Each IProcedure has zero or more IParameter objects. The
			IParameter objects describe the input parameters, the output result
			set, and the output parameters.  </para>
    </sect2>
    
    <sect2>
      <title>IBatchedUpdate Structure </title>

		<para>Each IBatchedUpdate has a list of ICommand objects (which must be
			an IInsert, IUpdate, or IDelete) that compose the batch. </para>    
    </sect2>
  </sect1>

  <sect1>
    <title>Language Utilities</title>
    <para>This section covers utilities available when using, creating, and manipulating the language interfaces.</para>
    
    <sect2>
      <title>Data Types</title>
      <para>The Connector API contains an interface TypeFacility that defines data types and provides value translation facilities.  </para>

	<para>This ConnectorEnvironment (provided by Teiid on connector start)
		is a factory to obtain a TypeFacility instance for the connector using
		the getTypeFacility() method.
		The TypeFacitlity interface has methods that support data type
		transformation and detection of appropriate runtime or JDBC types.
		 The TypeFacility.RUNTIME_TYPES and TypeFacility.RUNTIME_NAMES
		interfaces defines constants for all Teiid runtime data types.  All
		IExpression instances define a data type based on this set of types.
		 These constants are often needed in understanding or creating
		language interfaces.</para>
    </sect2>

    <sect2>
      <title>Language Manipulation</title>
		<para>In connectors that support a fuller set of capabilities (those
			that generally are translating to a language of comparable to SQL),
			there is often a need to manipulate or create language interfaces to
			move closer to the syntax of choice.  Some utilities are provided for
			this purpose:</para>
		<para>Similar to the TypeFacility, you can use the ConnectorEnvironment
			to get a reference to the ILanguageFactory instance for your
			connector.  This interface is a factory that can be used to create new
			instances of all the concrete language interface objects.  </para>
		<para>Some helpful utilities for working with ICriteria objects are
			provided in the LanguageUtil class.  This class has methods to combine
			ICriteria with AND or to break an ICriteria apart based on AND
			operators.  These utilities are helpful for breaking apart a criteria
			into individual filters that your connector can implement.</para>
    </sect2>      
  </sect1>  
    
  <sect1>
    <title>Runtime Metadata</title>
		<para>Teiid uses a library of metadata, known as "runtime metadata” for
			each virtual database that is deployed in Teiid. The runtime metadata
			is a subset of metadata as defined by models in the Teiid models that
			compose the virtual database.  </para>
		<para>Connectors can access runtime metadata by using the interfaces
			defined in org.teiid.connector.metadata.runtime.  This package defines
			interfaces representing a MetadataID, a MetadataObject, and ways to
			navigate those IDs and objects.</para>

    <sect2>
      <title>Language Objects</title>
      <para>One language interface, IMetadataReference describes whether a language object has a reference to a MetadataObject.  The following interfaces extend IMetadataReference:</para>
      <itemizedlist>
        <listitem><para>IElement</para> - returns an Element MetadataObject</listitem>
        <listitem><para>IGroup</para> - returns a Group MetadataObject</listitem>
        <listitem><para>IProcedure</para> - returns a Procedure MetadataObject</listitem>
        <listitem><para>IParameter</para> - returns a Parameter MetadataObject</listitem>
      </itemizedlist>

      <para>Once a MetadataObject has been obtained, it is possible to use it metadata about that object or to find other related or objects.</para>
    </sect2>
    <sect2>
      <title>Access to Runtime Metadata</title>

		<para>As mentioned in the previous section, a MetadataID is obtained
			from one of the language objects. That MetadataID can then be used
			directly to obtain information about the ID, such as the full name or
			short name.  </para>
		<para>The RuntimeMetadata interface is passed in for the creation of an Execution. It provides the ability to look up
			MetadataObjects based on their fully qualified names in the VDB. There are several kinds of
			MetadataObjects and they can be used to find more information about
			the object in runtime metadata.  </para>
		<para>Currently, only a subset of the most commonly used runtime
			metadata is available through these interfaces. In the future, more
			complete information will be available.</para>

      <para><emphasis>Obtaining MetadataObject Properties Example</emphasis></para>

      <para>The process of getting an element's properties is sometimes needed for connector development.  For example to get the NameInSource property or all extension properties:</para>
      <programlisting><![CDATA[
//getting the Group metadata from an IGroup is straight-forward
IGroup igroup = ... //some group on a command
Group group = igroup.getMetadataObject();

//we could also use the runtime metadata
RuntimeMetadata rm = ... //Obtained from the creation of the Execution

group = rm.getGroup("fully.qualified.name"); 
String contextName = group.getNameInSource();

//The props will contain extension properties
Properties props = group.getProperties();       
      ]]></programlisting>
      
    </sect2>
  </sect1>
  
  <sect1>
    <title>Language Visitors</title>
    
    <sect2>
      <title>Framework</title>
		<para>The Connector API provides a language visitor framework in the
			org.teiid.connector.visitor.framework package.   The framework
			provides utilities useful in navigating and extracting information
			from trees of language objects.</para>
	
		<para>The visitor framework is a variant of the Visitor design pattern,
			which is documented in several popular design pattern references.  The
			visitor pattern encompasses two primary operations: traversing the
			nodes of a graph (also known as iteration) and performing some action
			at each node of the graph.  In this case, the nodes are language
			interface objects and the graph is really a tree rooted at some node.
			 The provided framework allows for customization of both aspects of
			visiting.</para>
		<para>The base LanguageObjectVisitor class defines the visit methods
			for all leaf language interfaces that can exist in the tree.  The
			LanguageObject interface defines an acceptVisitor() method – this
			method will call back on the visit method of the visitor to complete
			the contract.  A base class with empty visit methods is provided as
			AbstractLanguageVisitor.  The AbstractLanguageVisitor is just a
			visitor shell – it performs no actions when visiting nodes and does
			not provide any iteration.</para>
		<para>The HierarchyVisitor provides the basic code for walking a
			language object tree.  The HierarchyVisitor performs no action as it
			walks the tree – it just encapsulates the knowledge of how to walk it.
			 If your connector wants to provide a custom iteration that walks the
			objects in a special order (to exclude nodes, include nodes multiple
			times, conditionally include nodes, etc) then you must either extend
			HierarchyVisitor or build your own iteration visitor.  In general,
			that is not necessary.</para>
		<para>The DelegatingHierarchyVisitor is a special subclass of the
			HierarchyVisitor that provides the ability to perform a different
			visitor’s processing before and after iteration.  This allows users of
			this class to implement either pre- or post-order processing based on
			the HierarchyVisitor.  Two helper methods are provided on
			DelegatingHierarchyVisitor to aid in executing pre- and post-order
			visitors.   </para>
    </sect2>
    <sect2>
      <title>Provided Visitors</title>
		<para>The SQLStringVisitor is a special visitor that can traverse a
			tree of language interfaces and output the equivalent Teiid SQL.  This
			visitor can be used to print language objects for debugging and
			logging.  The SQLStringVisitor does not use the HierarchyVisitor
			described in the last section; it provides both iteration and
			processing type functionality in a single custom visitor.    </para>
		<para>The CollectorVisitor is a handy utility to collect all language
			objects of a certain type in a tree. Some additional helper methods
			exist to do common tasks such as retrieving all elements in a tree,
			retrieving all groups in a tree, and so on.  </para>
    </sect2>
    <sect2>
      <title>Writing a Visitor</title>
		<para>Writing your own visitor can be quite easy if you use the
			provided facilities.  If the normal method of iterating the language
			tree is sufficient, then just follow these steps:</para>
		<para>Create a subclass of AbstractLanguageVisitor.  Override any visit
			methods needed for your processing.  For instance, if you wanted to
			count the number of elements in the tree, you need only override the
			visit(IElement) method.  Collect any state in local variables and
			provide accessor methods for that state.</para>
		<para>Decide whether to use pre-order or post-order iteration. Note
			that visitation order is based upon syntax ordering of SQL clauses -
			not processing order.</para>
		<para>Write code to execute your visitor using the utility methods on
			DelegatingHierarchyVisitor:</para>
      <programlisting><![CDATA[
// Get object tree 
ILanguageObject objectTree = …

// Create your visitor initialize as necessary
MyVisitor visitor = new MyVisitor();

// Call the visitor using pre-order visitation
DelegatingHierarchyVisitor.preOrderVisit(visitor, objectTree);

// Retrieve state collected while visiting
int count = visitor.getCount();       
      ]]></programlisting>      
    </sect2>
  </sect1>
  <sect1 id="connector_capabilities">
    <title>Connector Capabilities</title>
	<para>All connectors must return a ConnectorCapabilities class from the
		<code>Connection.getCapabilities()</code> or <code>Connector.getCapabilities()</code> method. This class is used by the
		Connector Manager to determine what kinds of commands the connector is
		capable of executing. A basic implementation of the
		ConnectorCapabilities interface is supplied at
		BasicConnectorCapabilities. This
		capabilities class specifies that the connector does not support any capability. You should extend
		this class and override the necessary methods to specify which
		capabilities your connector supports.  </para>
    <sect2>
      <title>Capability Scope</title>
		<para>
			Note that if your capabilities will remain unchanged for the lifetime
			of the connector, you should return them via
			<code>Connector.getCapabilities()</code>
			since the engine will cache them for reuse by all connections to the
			connector.  Capabilities returned by the connection will only be cached for the duration of the user request.
		</para>
    </sect2>
    <sect2>
      <title>Capabilities</title>
        <para>The following table lists the capabilities that can be specified in the ConnectorCapabilities class.</para>
        <table frame='all'>
          <title>Available Connector Capabilities</title>
          <tgroup cols='3' align='left' colsep='1' rowsep='1'>
            <colspec colname='c1' colwidth="1.5*" />
            <colspec colname='c2' colwidth="1*" />
            <colspec colname='c3' colwidth="2*" />
            <thead>
              <row>
                <entry>
                  <para>Capability</para>
                </entry>
                <entry>
                  <para>Requires</para>
                </entry>
                <entry>
                  <para>Description</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>SelectDistinct</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support SELECT DISTINCT in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelectExpression</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support SELECT of more than just element references.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AliasedGroup</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support groups in the FROM clause that have an alias.
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SupportedJoinCriteria</para>
                </entry>
                <entry>
                  <para>At least one of the join type supports.</para>
                </entry>
                <entry>
					<para>Returns one of the SupportedJoinCriteria enum types: ANY, THETA,
						EQUI, KEY. KEY is the most restrictive, indicating that the source
						only supports equi-join criteria specified on the primary key of at
						least one of the tables in join.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InnerJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support inner and cross joins</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfJoins</para>
                </entry>
                <entry>
                  <para>AliasedGroups and at least on of the join type supports.</para>
                </entry>
                <entry>
                  <para>Connector can support a self join between two aliased versions of the
                    same group.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OuterJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support LEFT and RIGHT OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FullOuterJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support FULL OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InlineViews</para>
                </entry>
                <entry>
                  <para>AliasedGroup</para>
                </entry>
                <entry>
                  <para>Connector can support a named subquery in the FROM clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>BetweenCriteria</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Not currently used - between criteria is rewriten as compound comparisions.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaEquals</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator "=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaOrdered</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator "&gt;” or "&lt;".</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support LIKE criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteriaEscapeCharacter</para>
                </entry>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support LIKE criteria with an ESCAPE character clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support IN predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteriaSubquery</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support IN predicate criteria where values are supplied by a
                    subquery.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>IsNullCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support IS NULL predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the OR logical criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>NotCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
					<para>Connector can support the NOT logical criteria. IMPORTANT: This
						capability also applies to negation of predicates, such as specifying
						IS NOT NULL, "&lt;=" (not "&gt;"), "&gt;=" (not "&lt;"), etc.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ExistsCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support EXISTS predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaAll</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria using the ALL
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaSome</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria using the SOME or ANY
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support the ORDER BY clause in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderByUnrelated</para>
                </entry>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para>Connector can support the ORDER BY items that are not directly specified in the select clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support an explict GROUP BY clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Having</para>
                </entry>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para>Connector can support the HAVING clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesAvg</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the AVG aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCount</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the COUNT aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCountStar</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the COUNT(*) aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesDistinct</para>
                </entry>
                <entry>
                  <para>At least one of the aggregate functions.</para>
                </entry>
                <entry>
                  <para>Connector can support the keyword DISTINCT inside an aggregate function.  This
                    keyword indicates that duplicate values within a group of rows will be ignored.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMax</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the MAX aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMin</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the MIN aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesSum</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the SUM aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ScalarSubqueries</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support the use of a subquery in a scalar context (wherever an
                    expression is valid).</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CorrelatedSubqueries</para>
                </entry>
                <entry>
                  <para>At least one of the subquery pushdown capabilities.</para>
                </entry>
                <entry>
                  <para>Connector can support a correlated subquery that refers to an element in
                    the outer query.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Not currently used - simple case is rewriten as searched case.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SearchedCaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support "searched” CASE expressions anywhere that expressions are
                    accepted.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Unions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector support UNION and UNION ALL</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Intersect</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector supports INTERSECT</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Except</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector supports Except</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SetQueryOrderBy</para>
                </entry>
                <entry>
                  <para>Unions, Intersect, or Except</para>
                </entry>
                <entry>
                  <para>Connector supports set queries with an ORDER BY</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowLimit</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the limit portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowOffset</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector can support the offset portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FunctionsInGroupBy</para>
                </entry>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para>Not currently used - non-element expressions in the group by create an inline view.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InsertWithQueryExpression</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector supports INSERT statements with values specified by an IQueryCommand.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
		<para>Note that any pushdown subquery must itself be compliant with the
			connector capabilities.</para>
      </sect2>
      
      <sect2 id="command_form_capabilities">
        <title>Command Form</title>
		<para>The method ConnectorCapabilities.useAnsiJoin() should return true
			if the Connector prefers the use of ANSI style join structure for
			join trees that contain only INNER and CROSS joins.</para>
		<para>The method ConnectorCapabilities.requiresCriteria() should return
			true if the Connector requires criteria for any Query, Update, or
			Delete. This is a replacement for the model support property "Where
			All".</para>
      </sect2>
      
      <sect2>
        <title>Scalar Functions</title>
		<para>The method ConnectorCapabilities.getSupportedFunctions() can be
			used to specify which scalar functions the connector supports.  The
			set of possible functions is based on the set of functions supported
			by Teiid.  This set can be found in the <ulink url="&docUrl;">Reference</ulink>
			documentation.  If the connector states that it supports a function,
			it must support all type combinations and overloaded forms of that
			function.</para>
		<para>There are also five standard operators that can also be specified in the
			supported function list: +, -, *, /, and ||.</para>
		<para>The constants interface SourceSystemFunctions contains the string
			names of all possible built-in pushdown functions. Note that not all
			system functions appear in this list. This is because some system
			functions will always be evaluted in Teiid, are simple aliases to
			other functions, or are rewriten to a more standard expression.</para>
      </sect2>

      <sect2>
        <title>Physical Limits</title>
		<para>The method ConnectorCapabilities.getMaxInCriteriaSize() can be
			used to specify the maximum number of values that can be passed in an
			IN criteria.  This is an important constraint as an IN criteria is
			frequently used to pass criteria between one source and another using
			a dependent join.</para>
		<para>The method ConnectorCapabilities.getMaxFromGroups() can be used
			to specify the maximum number of FROM Clause groups that can used in a
			join. -1 indicates there is no limit.</para>
      </sect2>
      
      <sect2>
        <title>Update Execution Modes</title>
		<para>The method ConnectorCapabilities.supportsBatchedUpdates() can be
			used to indicate that the connector supports executing the
			IBatchedUpdates command.
			</para>
		<para>The method ConnectorCapabilities.supportsBulkUpdate() can be used
			to indicate that the connector accepts update commands containg multi valued ILiterals.</para>
		<para>Note that if the connector does not support either of these
			update modes, the query engine will compensate by issuing the updates
			individually.</para>
      </sect2>
      
   </sect1>

</chapter>