<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../../../../../../docbook/custom.dtd">
%CustomDTD;
]>
<chapter id="command_language">
  <title>Command Language</title>
  
  <sect1>
    <title>Language Interfaces</title>
	<para>
		Teiid sends commands to your Translator in object form. The interfaces
		for these objects are all defined in the "org.teiid.language"
		package. These interfaces can be combined to represent any possible
		command that Teiid may send to the Translator. However, it is possible
		to notify Teiid that your Translator can only accept certain kinds of
		commands via the capabilities defined on the "ExecutionFactory" class. See the section on using
		<link linkend="translator_capabilities">Translator Capabilities</link>
		for more information.
	</para>
	<para>The language interfaces all extend from the <emphasis>LanguageObject</emphasis> interface.
		Language objects should be thought of as a tree where each node is a
		language object that has zero or more child language objects of types
		that are dependent on the current node.</para>
	<para>All commands sent to your Translator are in the form of these
		language trees, where the root of the tree is a subclass of <emphasis>Command</emphasis>.
		Command has several sub-interfaces, namely: 
        
        <itemizedlist>
            <listitem><para><code>QueryExpression</code></para></listitem>
            <listitem><para><code>Insert</code></para></listitem>
            <listitem><para><code>Update</code></para></listitem>
            <listitem><para><code>Delete</code></para></listitem>
            <listitem><para><code>BatchedUpdate</code></para></listitem>
            <listitem><para><code>Call</code></para></listitem>
        </itemizedlist>        
        
		Important components of	these commands are expressions, criteria, and joins, which are examined
		in closer detail below. Also see the	<ulink url="&javaDocUrl;">Teiid JavaDocs</ulink>
		for more on the classes and interfaces described here.
	</para>
    <sect2>
      <title>Expressions</title>
		<para>An expression represents a single value in context, although in
			some cases that value may change as the query is evaluated.  For
			example, a literal value, such as 5 represents an integer value.  An
			element reference such as "table.EmployeeName" represents a column in a data source
			and may logically take on many values while the command is being
			evaluated.</para>
      <itemizedlist>
	<listitem>
		<para>
			<code>Expression</code>
			– base expression interface
		</para>
	</listitem>
	<listitem>
		<para>
			<code>Element</code>
			– represents an element in the data source
		</para>
	</listitem>
	<listitem>
		<para>
			<code>Literal</code>
			– represents a literal scalar value, but may also be multi-valued in
			the case of bulk updates.
		</para>
	</listitem>
	<listitem>
		<para>
			<code>Function</code>
			– represents a scalar function with parameters that are also Expressions
		</para>
	</listitem>
	<listitem>
		<para>
			<code>Aggregate</code>
			– represents an aggregate function which holds a single expression
		</para>
	</listitem>
	<listitem>
		<para>
			<code>ScalarSubquery</code>
			– represents a subquery that returns a single value
		</para>
	</listitem>
	<listitem>
		<para>
			<code>SearchedCase, SearchedWhenClause</code>
			– represents a searched CASE expression.  The searched CASE
			expression evaluates the criteria in WHEN clauses till one evaluates
			to TRUE, then evaluates the associated THEN clause.
		</para>
	</listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Condition</title>
		<para>A criteria is a combination of expressions and operators that
			evaluates to true, false, or unknown.  Criteria are most commonly used in the
			WHERE or HAVING clauses.</para>
      
      <itemizedlist>
        <listitem><para><code>Condition</code> – the base criteria interface</para></listitem>        
        <listitem><para><code>Not</code> – used to NOT another criteria</para></listitem>
        <listitem><para><code>AndOr</code> – used to combine other criteria via AND or OR</para></listitem>
        <listitem><para><code>SubuqeryComparison</code> – represents a comparison criteria with a subquery including a quantifier such as SOME or ALL</para></listitem>        
        <listitem><para><code>Comparison</code> – represents a comparison criteria with =, &gt;, &lt;, etc.</para></listitem>        
        <listitem><para><code>BaseInCondition</code> – base class for an IN criteria</para></listitem>        
        <listitem><para><code>In</code> – represents an IN criteria that has a set of expressions for values</para></listitem>        
        <listitem><para><code>SubqueryIn</code> – represents an IN criteria that uses a subquery to produce the value set</para></listitem>
        <listitem><para><code>IsNull</code> – represents an IS NULL criteria</para></listitem>        
        <listitem><para><code>Exists</code> – represents an EXISTS criteria that determines whether a subquery will return any values</para></listitem>
        <listitem><para><code>Like</code> – represents a LIKE criteria that compares string values</para></listitem>
      </itemizedlist>                  
    </sect2>
    
    <sect2>
      <title>The FROM Clause</title>
		<para>The FROM clause contains a list of <emphasis>TableReference</emphasis>.  </para>
      
      <itemizedlist>
        <listitem><para><code>TableReference</code> – represents a single Table</para></listitem>
        <listitem><para><code>Join</code> – has a left and right <code>TableReference</code> and information on the join between the items</para></listitem>
        <listitem><para><code>DerivedTable</code> – represents a table defined by an inline <code>QueryExpression</code></para></listitem>
      </itemizedlist>
    <para>
        A list of <emphasis>TableReference</emphasis>
        are used by default, in the pushdown query
        when no outer joins are used. If an outer join is used anywhere in the
        join tree, there will be a tree of
        <code>Join</code>
        s with a single root. This latter form
        is the ANSI perfered style. If you wish all pushdown queries containing joins to be in ANSI style have the
        capability "useAnsiJoin" return true. See
        <link linkend="command_form_capabilities">Command Form Capabilities</link>
        for more information.
    </para>
    </sect2>
	<sect2>
		<title>QueryExpression Structure</title>
		<para><emphasis>QueryExpression</emphasis> is the base for both queries and set queries.  It may optionally take an
         <emphasis>OrderBy</emphasis> (representing a SQL ORDER BY clause) and a <emphasis>Limit</emphasis> (represent a SQL LIMIT clause)</para>
    </sect2>      

    <sect2>
      <title>Select Structure</title>

		<para>Each <emphasis>QueryExpression</emphasis> can be a <emphasis>Select</emphasis> describing the expressions
			(typically elements) being selected and an <emphasis>TableReference</emphasis> specifying the table
			or tables being selected from, along with any join information.  The
			<emphasis>Select</emphasis> may optionally also supply an <emphasis>Condition</emphasis> (representing a SQL
			WHERE clause), an <emphasis>GroupBy</emphasis> (representing a SQL GROUP BY clause), an
			an <emphasis>Condition</emphasis> (representing a SQL HAVING clause).</para>
    </sect2>
    
    <sect2>
      <title>SetQuery Structure</title>

		<para>A <emphasis>QueryExpression</emphasis> can also be a <emphasis>SetQuery</emphasis> that represents on of the SQL set operations (UNION,
			INTERSECT, EXCEPT) on two <emphasis>QueryExpression</emphasis>. The all flag may be set to
			indicate UNION ALL (currently INTERSECT and EXCEPT ALL are not allowed in Teiid)</para>
    </sect2>
        
    <sect2>    
      <title>Insert Structure</title>

		<para>Each <emphasis>Insert</emphasis> will have a single <emphasis>NamedTable</emphasis> specifying the table being
			inserted into.  It will also has a list of <emphasis>ColumnReference</emphasis> specifying the columns 
            of the <emphasis>TableReference</emphasis> that are being inserted into. It also has
            <emphasis>InsertValueSource</emphasis>, which will either be a list of 
            <emphasis>Expression(ExpressionValueSource)</emphasis>  or <emphasis>QueryExpression</emphasis></para>
    </sect2>

    <sect2>
      <title>Update Structure</title>

		<para>Each <emphasis>Update</emphasis> will have a single <emphasis>NamedTable</emphasis> specifying the table being
			updated and list of <emphasis>SetClause</emphasis> entries that specify <emphasis>ColumnReference</emphasis> 
            and <emphasis>Expression</emphasis> pairs for the update.	The Update may optionally provide a criteria 
			<emphasis>Condition</emphasis> specifying which rows should be updated.</para>
    </sect2>

    <sect2>
      <title>Delete Structure</title>

		<para>Each <emphasis>Delete</emphasis> will have a single <emphasis>NamedTable</emphasis> specifying the table being
			deleted from. It may also optionally have a criteria specifying which rows should be deleted.  </para>
    </sect2>

    <sect2>
      <title>Call Structure</title>

		<para>Each <emphasis>Call</emphasis> has zero or more <emphasis>Argument</emphasis> objects. The
			<emphasis>Argument</emphasis> objects describe the input parameters, the output result
			set, and the output parameters.  </para>
    </sect2>
    
    <sect2>
      <title>BatchedUpdates Structure </title>
		<para>Each <emphasis>BatchedUpdates</emphasis> has a list of <emphasis>Command</emphasis> objects (which must be either
			<emphasis>Insert</emphasis>, <emphasis>Update</emphasis> or <emphasis>Delete</emphasis>) that compose the batch. </para>    
    </sect2>
  </sect1>

  <sect1>
    <title>Language Utilities</title>
    <para>This section covers utilities available when using, creating, and manipulating the language interfaces.</para>
    
    <sect2>
      <title>Data Types</title>
      <para>The Translator API contains an interface <emphasis>TypeFacility</emphasis> that defines 
      data types and provides value translation facilities. This interface can be obtained from calling "getTypeFacility()" 
      method on the "ExecutionFactory" class.</para>

	<para>
		The TypeFacitlity interface has methods that support data type
		transformation and detection of appropriate runtime or JDBC types.
		 The TypeFacility.RUNTIME_TYPES and TypeFacility.RUNTIME_NAMES
		interfaces defines constants for all Teiid runtime data types.  All
		<emphasis>Expression</emphasis> instances define a data type based on this set of types.
		 These constants are often needed in understanding or creating language interfaces.</para>
    </sect2>

    <sect2>
      <title>Language Manipulation</title>
		<para>In Translators that support a fuller set of capabilities (those
			that generally are translating to a language of comparable to SQL),
			there is often a need to manipulate or create language interfaces to
			move closer to the syntax of choice.  Some utilities are provided for
			this purpose:</para>
		<para>Similar to the TypeFacility, you can call "getLanguageFactory()" method on 
            the "ExecutionFactory"
			to get a reference to the <emphasis>LanguageFactory</emphasis> instance for your
			translator.  This interface is a factory that can be used to create new
			instances of all the concrete language interface objects.  </para>
		<para>Some helpful utilities for working with <emphasis>Condition</emphasis> objects are
			provided in the <emphasis>LanguageUtil</emphasis> class.  This class has methods to combine
			<emphasis>Condition</emphasis> with AND or to break an <emphasis>Condition</emphasis> apart based on AND
			operators.  These utilities are helpful for breaking apart a criteria
			into individual filters that your translator can implement.</para>
    </sect2>      
  </sect1>  
    
  <sect1>
    <title>Runtime Metadata</title>
		<para>Teiid uses a library of metadata, known as "runtime metadata” for
			each virtual database that is deployed in Teiid. The runtime metadata
			is a subset of metadata as defined by models in the Teiid models that
			compose the virtual database.  While builing your VDB in the Designer, you can define what 
            called "Extension Model", that defines any number of arbitary properties on a model and its objects.
            At runtime, using this runtime metadata interface, you get access to those set properties defined during the 
            design time, to define/hint any execution behavior. For example, a XML model could define the 'xpath' as 
            one of the property on Column of a Table.</para>
                    
		<para>Translator gets access to the <emphasis>RuntimeMetadata</emphasis> interface at the time of <emphasis>Excecution</emphasis> creation.
            Translators can access runtime metadata by using the interfaces
			defined in <emphasis>org.teiid.metadata</emphasis> package.  This package defines
			API representing a Schema, Table, Columns and Procedures, and ways to navigate these objects.</para>

    <sect2>
      <title>Language Objects</title>
      <para>All the language objects extend <emphasis>AbstractMetadataRecord</emphasis> class</para>
      <itemizedlist>
        <listitem><para>Column - returns Column metadata record</para></listitem>
        <listitem><para>Table - returns a Table metadata record</para></listitem>
        <listitem><para>Procedure - returns a Procedure metadata record</para></listitem>
        <listitem><para>ProcedureParameter - returns a Procedure Parameter metadata record</para></listitem>
      </itemizedlist>

      <para>Once a metadata record has been obtained, it is possible to use its metadata about that object or to find other related or objects.</para>
    </sect2>
    <sect2>
      <title>Access to Runtime Metadata</title>

		<para>The RuntimeMetadata interface is passed in for the creation of an "Execution". See "createExecution" 
            method on the "ExecutionFactory" class. It provides the ability to look up
			metadta records based on their fully qualified names in the VDB. There are several kinds of
			metadata objects and they can be used to find more information about
			the objects in runtime metadata.  </para>
		

      <para><emphasis>Obtaining Metadata Properties Example</emphasis></para>

      <para>The process of getting an Table's properties is sometimes needed for translator development.  For example 
      to get the "NameInSource" property or all extension properties:</para>
      <programlisting><![CDATA[
//getting the Table metadata from an Table is straight-forward
Table table = runtimeMetadata.getTable("table-name");
String contextName = table.getNameInSource();

//The props will contain extension properties
Properties props = table.getProperties();       
      ]]></programlisting>
      
    </sect2>
  </sect1>
  
  <sect1>
    <title>Language Visitors</title>
    
    <sect2>
      <title>Framework</title>
		<para>The API provides a language visitor framework in the
			<emphasis>org.teiid.language.visitor</emphasis> package.  The framework
			provides utilities useful in navigating and extracting information
			from trees of language objects.</para>
	
		<para>The visitor framework is a variant of the Visitor design pattern,
			which is documented in several popular design pattern references.  The
			visitor pattern encompasses two primary operations: traversing the
			nodes of a graph (also known as iteration) and performing some action
			at each node of the graph.  In this case, the nodes are language
			interface objects and the graph is really a tree rooted at some node.
			 The provided framework allows for customization of both aspects of
			visiting.</para>
		<para>The base <emphasis>AbstractLanguageVisitor</emphasis> class defines the visit methods
			for all leaf language interfaces that can exist in the tree.  The
			LanguageObject interface defines an acceptVisitor() method – this
			method will call back on the visit method of the visitor to complete
			the contract.  A base class with empty visit methods is provided as
			AbstractLanguageVisitor.  The AbstractLanguageVisitor is just a
			visitor shell – it performs no actions when visiting nodes and does
			not provide any iteration.</para>
		<para>The <emphasis>HierarchyVisitor</emphasis> provides the basic code for walking a
			language object tree.  <emphasis>The HierarchyVisitor</emphasis> performs no action as it
			walks the tree – it just encapsulates the knowledge of how to walk it.
			 If your translator wants to provide a custom iteration that walks the
			objects in a special order (to exclude nodes, include nodes multiple
			times, conditionally include nodes, etc) then you must either extend
			HierarchyVisitor or build your own iteration visitor.  In general,
			that is not necessary.</para>
		<para>The <emphasis>DelegatingHierarchyVisitor</emphasis> is a special subclass of the
			HierarchyVisitor that provides the ability to perform a different
			visitor’s processing before and after iteration.  This allows users of
			this class to implement either pre- or post-order processing based on
			the HierarchyVisitor.  Two helper methods are provided on
			<emphasis>DelegatingHierarchyVisitor</emphasis> to aid in executing pre- and post-order
			visitors.   </para>
    </sect2>
    <sect2>
      <title>Provided Visitors</title>
		<para>The <emphasis>SQLStringVisitor</emphasis> is a special visitor that can traverse a
			tree of language interfaces and output the equivalent Teiid SQL.  This
			visitor can be used to print language objects for debugging and
			logging.  The <emphasis>SQLStringVisitor</emphasis> does not use the <emphasis>HierarchyVisitor</emphasis>
			described in the last section; it provides both iteration and
			processing type functionality in a single custom visitor.    </para>
		<para>The <emphasis>CollectorVisitor</emphasis> is a handy utility to collect all language
			objects of a certain type in a tree. Some additional helper methods
			exist to do common tasks such as retrieving all elements in a tree,
			retrieving all groups in a tree, and so on.  </para>
    </sect2>
    <sect2>
      <title>Writing a Visitor</title>
		<para>Writing your own visitor can be quite easy if you use the
			provided facilities.  If the normal method of iterating the language
			tree is sufficient, then just follow these steps:</para>
		<para>Create a subclass of AbstractLanguageVisitor.  Override any visit
			methods needed for your processing.  For instance, if you wanted to
			count the number of elements in the tree, you need only override the
			<emphasis>visit(ColumnReference)</emphasis> method.  Collect any state in local variables and
			provide accessor methods for that state.</para>
		<para>Decide whether to use pre-order or post-order iteration. Note
			that visitation order is based upon syntax ordering of SQL clauses -
			not processing order.</para>
		<para>Write code to execute your visitor using the utility methods on
			DelegatingHierarchyVisitor:</para>
      <programlisting><![CDATA[
// Get object tree 
LanguageObject objectTree = …

// Create your visitor initialize as necessary
MyVisitor visitor = new MyVisitor();

// Call the visitor using pre-order visitation
DelegatingHierarchyVisitor.preOrderVisit(visitor, objectTree);

// Retrieve state collected while visiting
int count = visitor.getCount();       
      ]]></programlisting>      
    </sect2>
  </sect1>
  <sect1 id="translator_capabilities">
    <title>Translator Capabilities</title>
	<para>The <emphasis>ExecutionFactory</emphasis> class defines all the methods that describe the capabilities of a Translator. 
       These are used by the Connector Manager to determine what kinds of commands the translator is
		capable of executing. A base  <emphasis>ExecutionFactory</emphasis> class implements all the basic capabilities, which says
        your translator does not support any cpabilities. Your extended 
        <emphasis>ExecutionFactory</emphasis> class must override the the necessary methods to specify which
		capabilities your translator supports.  </para>
    <sect2>
      <title>Capability Scope</title>
		<para>
			Note that if your capabilities will remain unchanged for the lifetime
			of the translator, since the engine will cache them for reuse by all instances of that
			translator.  Capabilities based on connection/user are not supported.
		</para>
    </sect2>
    <sect2>
      <title>Capabilities</title>
        <para>The following table lists the capabilities that can be specified in the <emphasis>ExecutionFactory</emphasis> class.</para>
        <table frame='all'>
          <title>Available Capabilities</title>
          <tgroup cols='3' align='left' colsep='1' rowsep='1'>
            <colspec colname='c1' colwidth="1.5*" />
            <colspec colname='c2' colwidth="1*" />
            <colspec colname='c3' colwidth="2*" />
            <thead>
              <row>
                <entry>
                  <para>Capability</para>
                </entry>
                <entry>
                  <para>Requires</para>
                </entry>
                <entry>
                  <para>Description</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>SelectDistinct</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support SELECT DISTINCT in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelectExpression</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support SELECT of more than just column references.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AliasedTable</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support Tables in the FROM clause that have an alias.
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InnerJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support inner and cross joins</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfJoins</para>
                </entry>
                <entry>
                  <para>AliasedGroups and at least on of the join type supports.</para>
                </entry>
                <entry>
                  <para>Translator can support a self join between two aliased versions of the
                    same Table.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OuterJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support LEFT and RIGHT OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FullOuterJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support FULL OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InlineViews</para>
                </entry>
                <entry>
                  <para>AliasedTable</para>
                </entry>
                <entry>
                  <para>Translator can support a named subquery in the FROM clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>BetweenCriteria</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Not currently used - between criteria is rewriten as compound comparisions.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaEquals</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support comparison criteria with the operator "=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaOrdered</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support comparison criteria with the operator "&gt;” or "&lt;".</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support LIKE criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteriaEscapeCharacter</para>
                </entry>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para>Translator can support LIKE criteria with an ESCAPE character clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteria</para>
                </entry>
                <entry>
                  <para>MaxInCriteria</para>
                </entry>
                <entry>
                  <para>Translator can support IN predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteriaSubquery</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support IN predicate criteria where values are supplied by a
                    subquery.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>IsNullCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support IS NULL predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the OR logical criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>NotCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
					<para>Translator can support the NOT logical criteria. IMPORTANT: This
						capability also applies to negation of predicates, such as specifying
						IS NOT NULL, "&lt;=" (not "&gt;"), "&gt;=" (not "&lt;"), etc.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ExistsCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support EXISTS predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaAll</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support a quantified comparison criteria using the ALL
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaSome</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support a quantified comparison criteria using the SOME or ANY
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support the ORDER BY clause in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderByUnrelated</para>
                </entry>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para>Translator can support the ORDER BY items that are not directly specified in the select clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support an explict GROUP BY clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Having</para>
                </entry>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para>Translator can support the HAVING clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesAvg</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the AVG aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCount</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the COUNT aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCountStar</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the COUNT(*) aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesDistinct</para>
                </entry>
                <entry>
                  <para>At least one of the aggregate functions.</para>
                </entry>
                <entry>
                  <para>Translator can support the keyword DISTINCT inside an aggregate function.  This
                    keyword indicates that duplicate values within a group of rows will be ignored.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMax</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the MAX aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMin</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the MIN aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesSum</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the SUM aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ScalarSubqueries</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support the use of a subquery in a scalar context (wherever an
                    expression is valid).</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CorrelatedSubqueries</para>
                </entry>
                <entry>
                  <para>At least one of the subquery pushdown capabilities.</para>
                </entry>
                <entry>
                  <para>Translator can support a correlated subquery that refers to an element in
                    the outer query.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Not currently used - simple case is rewriten as searched case.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SearchedCaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support "searched” CASE expressions anywhere that expressions are
                    accepted.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Unions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator support UNION and UNION ALL</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Intersect</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports INTERSECT</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Except</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports Except</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SetQueryOrderBy</para>
                </entry>
                <entry>
                  <para>Unions, Intersect, or Except</para>
                </entry>
                <entry>
                  <para>Translator supports set queries with an ORDER BY</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowLimit</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the limit portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowOffset</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the offset portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FunctionsInGroupBy</para>
                </entry>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para>Not currently used - non-element expressions in the group by create an inline view.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InsertWithQueryExpression</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports INSERT statements with values specified by an QueryExpression.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>supportsBatchedUpdates</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports a batch of INSERT, UPDATE and DELETE commands to be executed together.</para>
                </entry>
              </row>   
              <row>
                <entry>
                  <para>supportsBulkUpdate</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports updates with multiple value sets</para>
                </entry>
              </row>         
            </tbody>
          </tgroup>
        </table>
		<para>Note that any pushdown subquery must itself be compliant with the	Translator capabilities.</para>
      </sect2>
      
      <sect2 id="command_form_capabilities">
        <title>Command Form</title>
		<para>The method <emphasis>ExecutionFactory.useAnsiJoin()</emphasis> should return true
			if the Translator prefers the use of ANSI style join structure for
			join trees that contain only INNER and CROSS joins.</para>
		<para>The method <emphasis>ExecutionFactory.requiresCriteria()</emphasis> should return
			true if the Translator requires criteria for any Query, Update, or
			Delete. This is a replacement for the model support property "Where
			All".</para>
      </sect2>
      
      <sect2>
        <title>Scalar Functions</title>
		<para>The method <emphasis>ExecutionFactory.getSupportedFunctions()</emphasis> can be
			used to specify which scalar functions the Translator supports.  The
			set of possible functions is based on the set of functions supported
			by Teiid.  This set can be found in the <ulink url="&docUrl;">Reference</ulink>
			documentation.  If the Translator states that it supports a function,
			it must support all type combinations and overloaded forms of that
			function.</para>
		<para>There are also five standard operators that can also be specified in the
			supported function list: +, -, *, /, and ||.</para>
		<para>The constants interface SourceSystemFunctions contains the string
			names of all possible built-in pushdown functions. Note that not all
			system functions appear in this list. This is because some system
			functions will always be evaluted in Teiid, are simple aliases to
			other functions, or are rewriten to a more standard expression.</para>
      </sect2>

      <sect2>
        <title>Physical Limits</title>
		<para>The method <emphasis>ExecutionFactory.getMaxInCriteriaSize()</emphasis> can be
			used to specify the maximum number of values that can be passed in an
			IN criteria.  This is an important constraint as an IN criteria is
			frequently used to pass criteria between one source and another using
			a dependent join.</para>
		<para>The method <emphasis>ExecutionFactory.getMaxFromGroups()</emphasis> can be used
			to specify the maximum number of FROM Clause groups that can used in a
			join. -1 indicates there is no limit.</para>
      </sect2>
      
      <sect2>
        <title>Update Execution Modes</title>
		<para>The method <emphasis>ExecutionFactory.supportsBatchedUpdates()</emphasis> can be
			used to indicate that the Translator supports executing the <emphasis>BatchedUpdates</emphasis> command.
			</para>
		<para>The method <emphasis>ExecutionFactory.supportsBulkUpdate()</emphasis> can be used
			to indicate that the Translator accepts update commands containg multi valued Literals.</para>
		<para>Note that if the translator does not support either of these
			update modes, the query engine will compensate by issuing the updates 	individually.</para>
      </sect2>
      
   </sect1>

</chapter>