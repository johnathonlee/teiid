<chapter id="command_language">
  <title>Command Language</title>
  
  <sect1>
    <title>Language Interfaces</title>
	<para>
		Teiid sends commands to your connector in object form. The interfaces
		for these objects are all defined in the org.teiid.connector.language
		package. These interfaces can be combined to represent any possible
		command that Teiid may send to the connector. However, it is possible
		to notify Teiid that your connector can only accept certain kinds of
		commands via the ConnectorCapabilities class. See the section on using
		<link linkend="connector_capabilities">Connector Capabilities</link>
		for more information.
	</para>
	<para>The language interfaces all extend from the main interface,
		ILanguageObject. They should be thought of as a tree where each node is a
		language object that has zero or more child language objects of types
		that are dependent on the current node.</para>
	<para>All commands sent to your connector are in the form of these
		language trees, where the root of the tree is a subclass of ICommand.
		ICommand has several sub-interfaces, namely: IQueryCommand, IInsert, IUpdate,
		IDelete, IBatchedUpdate, and IProcedure.  
		Important components of these commands are expressions, criteria, and
		joins, which are examined in closer detail below.</para>
    <sect2>
      <title>Expressions</title>
		<para>An expression represents a single value in context, although in
			some cases that value may change as the query is evaluated.  For
			example, a literal value, such as 5 represents an integer value.  An
			element reference such as "table.EmployeeName" represents a column in a data source
			and may logically take on many values while the command is being
			evaluated.</para>
      <itemizedlist>
	<listitem>
		<para>
			<code>IExpression</code>
			– base expression interface
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IElement</code>
			– represents an element in the data source
		</para>
	</listitem>
	<listitem>
		<para>
			<code>ILiteral</code>
			– represents a literal scalar value, but may also be multi-valued in
			the case of bulk updates.
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IFunction</code>
			– represents a scalar function with parameters that are also
			IExpressions
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IAggregate</code>
			– represents an aggregate function which holds a single expression
		</para>
	</listitem>
	<listitem>
		<para>
			<code>IScalarSubquery</code>
			– represents a subquery that returns a single value
		</para>
	</listitem>
	<listitem>
		<para>
			<code>ISearchedCaseExpression</code>
			– represents a searched CASE expression.  The searched CASE
			expression evaluates the criteria in WHEN clauses till one evaluates
			to TRUE, then evaluates the associated THEN clause.
		</para>
	</listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Criteria</title>
		<para>A criteria is a combination of expressions and operators that
			evaluates to true, false, or unknown.  Criteria are most commonly used in the
			WHERE or HAVING clauses.</para>
      
      <itemizedlist>
        <listitem><para><code>ICriteria</code> – the base criteria interface</para></listitem>
        <listitem><para><code>ILogicalCriteria</code> – used to logically combine other criteria</para></listitem>
        <listitem><para><code>INotCriteria</code> – used to NOT another criteria</para></listitem>
        <listitem><para><code>ICompoundCriteria</code> – used to combine other criteria via AND or OR</para></listitem>
        <listitem><para><code>IPredicateCriteria</code> – a predicate that evaluates to true, false, or unknown</para></listitem>
        <listitem><para><code>ISubuqeryCompareCriteria</code> – represents a comparison criteria with a subquery including a quantifier such as SOME or ALL</para></listitem>
        <listitem><para><code>ICompareCriteria</code> – represents a comparison criteria with =, &gt;, &lt;, etc.</para></listitem>
        <listitem><para><code>IBaseInCriteria</code> – base class for an IN criteria</para></listitem>
        <listitem><para><code>IInCriteria</code> – represents an IN criteria that has a set of expressions for values</para></listitem>
        <listitem><para><code>ISubqueryInCriteria</code> – represents an IN criteria that uses a subquery to produce the value set</para></listitem>
        <listitem><para><code>IIsNullCriteria</code> – represents an IS NULL criteria</para></listitem>
        <listitem><para><code>IExistsCriteria</code> – represents an EXISTS criteria that determines whether a subquery will return any values</para></listitem>
        <listitem><para><code>ILikeCriteria</code> – represents a LIKE criteria that compares string values</para></listitem>
      </itemizedlist>                  
    </sect2>
    
    <sect2>
      <title>The FROM Clause</title>
		<para>The FROM clause contains a list of IFromItems.  Each IFomItem can
			either represent a group or a join between two other IFromItems.  This
			allows joins to be composed into a join tree.</para>
      
      <itemizedlist>
        <listitem><para><code>IGroup</code> – represents a single group</para></listitem>
        <listitem><para><code>IJoin</code> – has a left and right <code>IFromItem</code> and information on the join between the items</para></listitem>
        <listitem><para><code>IInlineView</code> – represents a group defined by an inline <code>IQueryCommand</code></para></listitem>
      </itemizedlist>
		<para>A list of IFromItems is used by default in the pushdown query
			when no outer joins are used. If an outer join is used anywhere in the
			join tree there will be only one IFromItem, an IJoin. This latter form
			is the ANSI perfered style. If you wish all pushdown queries
			containing joins to be in ANSI style have the
			ConnectorCapability.useAnsiJoin return true.</para>
    </sect2>
	<sect2>
		<title>IQueryCommand Structure</title>
		<para>IQueryCommand (refered to in SQL as a Query Expression) is the base for both queries and set queries.  It may optionally take an IOrderBy (representing a SQL ORDER BY clause) and a ILimit (represent a SQL LIMIT clause)</para>
	</sect2>
    <sect2>
      <title>IQuery Structure</title>

		<para>Each IQuery will have an ISelect describing the expressions
			(typically elements) being selected and an IFrom specifying the group
			or groups being selected from, along with any join information.  The
			IQuery may optionally also supply an ICriteria (representing a SQL
			WHERE clause), an IGroupBy (representing a SQL GROUP BY clause), an
			an ICriteria (representing a SQL HAVING clause).</para>            
    </sect2>      

    <sect2>
      <title>ISetQuery Structure</title>

		<para>An ISetQuery represents on of the SQL set operations (UNION,
			INTERSECT, EXCEPT) on two IQueryCommands. The all flag may be set to
			indicate UNION ALL (currently INTERSECT and EXCEPT ALL are not allowed
			in Teiid)</para>
    </sect2>
        
    <sect2>    
      <title>IInsert Structure</title>

		<para>Each IInsert will have a single IGroup specifying the group being
			inserted into.  It will also a list of
			IElements specifying the columns of the IGroup that are being inserted
			into and an IInsertValueSource, which will either be a list of IExpression (IInsertExpressionValueSource) or an IQueryCommand.</para>
    </sect2>

    <sect2>
      <title>IUpdate Structure</title>

		<para>Each IUpdate will have a single IGroup specifying the group being
			updated.  The ISetClauseList contains ISetClause entries that specify
			IElement and IExpression pairs for the update.
			The IUpdate may optionally provide a
			criteria specifying which rows should be updated.</para>
    </sect2>

    <sect2>
      <title>IDelete Structure</title>

		<para>Each IDelete will have a single IGroup specifying the group being
			deleted from. It may also optionally have a criteria specifying which
			rows should be deleted.  </para>
    </sect2>

    <sect2>
      <title>IProcedure Structure</title>

		<para>Each IProcedure has zero or more IParameter objects. The
			IParameter objects describe the input parameters, the output result
			set, and the output parameters.  </para>
    </sect2>
    
    <sect2>
      <title>IBatchedUpdate Structure </title>

		<para>Each IBatchedUpdate has a list of ICommand objects (which must be
			an IInsert, IUpdate, or IDelete) that compose the batch. </para>    
    </sect2>
  </sect1>

  <sect1>
    <title>Language Utilities</title>
    <para>This section covers utilities available when using, creating, and manipulating the language interfaces.</para>
    
    <sect2>
      <title>Data Types</title>
      <para>The Connector API contains an interface TypeFacility that defines data types and provides value translation facilities.  </para>

	<para>This ConnectorEnvironment (provided by Teiid on connector start)
		is a factory to obtain a TypeFacility instance for the connector using
		the getTypeFacility() method.
		The TypeFacitlity interface has methods that support data type
		transformation and detection of appropriate runtime or JDBC types.
		 The TypeFacility.RUNTIME_TYPES and TypeFacility.RUNTIME_NAMES
		interfaces defines constants for all Teiid runtime data types.  All
		IExpression instances define a data type based on this set of types.
		 These constants are often needed in understanding or creating
		language interfaces.</para>
    </sect2>

    <sect2>
      <title>Language Manipulation</title>
		<para>In connectors that support a fuller set of capabilities (those
			that generally are translating to a language of comparable to SQL),
			there is often a need to manipulate or create language interfaces to
			move closer to the syntax of choice.  Some utilities are provided for
			this purpose:</para>
		<para>Similar to the TypeFacility, you can use the ConnectorEnvironment
			to get a reference to the ILanguageFactory instance for your
			connector.  This interface is a factory that can be used to create new
			instances of all the concrete language interface objects.  </para>
		<para>Some helpful utilities for working with ICriteria objects are
			provided in the LanguageUtil class.  This class has methods to combine
			ICriteria with AND or to break an ICriteria apart based on AND
			operators.  These utilities are helpful for breaking apart a criteria
			into individual filters that your connector can implement.</para>
    </sect2>      
  </sect1>  
    
  <sect1>
    <title>Runtime Metadata</title>
		<para>Teiid uses a library of metadata, known as “runtime metadata” for
			each virtual database that is deployed in Teiid. The runtime metadata
			is a subset of metadata as defined by models in the Teiid models that
			compose the virtual database.  </para>
		<para>Connectors can access runtime metadata by using the interfaces
			defined in org.teiid.connector.metadata.runtime.  This package defines
			interfaces representing a MetadataID, a MetadataObject, and ways to
			navigate those IDs and objects.</para>

    <sect2>
      <title>Language Objects</title>
      <para>One language interface, IMetadataReference describes whether a language object has a reference to a MetadataObject.  The following interfaces extend IMetadataReference:</para>
      <itemizedlist>
        <listitem><para>IElement</para></listitem>
        <listitem><para>IGroup</para></listitem>
        <listitem><para>IProcedure</para></listitem>
        <listitem><para>IParameter</para></listitem>
      </itemizedlist>

      <para>Once a MetadataObject has been obtained, it is possible to use it metadata about that object or to find other related or objects.</para>
    </sect2>
    <sect2>
      <title>Access to Runtime Metadata</title>

		<para>As mentioned in the previous section, a MetadataID is obtained
			from one of the language objects. That MetadataID can then be used
			directly to obtain information about the ID, such as the full name or
			short name.  </para>
		<para>The RuntimeMetadata interface is passed in for the creation of an Execution. It provides the ability to look up
			MetadataObjects based on their fully qualified names in the VDB. There are several kinds of
			MetadataObjects and they can be used to find more information about
			the object in runtime metadata.  </para>
		<para>Currently, only a subset of the most commonly used runtime
			metadata is available through these interfaces. In the future, more
			complete information will be available.</para>

      <para><emphasis>Obtaining MetadataObject Properties Example</emphasis></para>

      <para>The process of getting an element's properties is sometimes needed for connector development.  For example to get the NameInSource property or all extension properties:</para>
      <programlisting><![CDATA[
//getting the Group metadata from an IGroup is straight-forward
IGroup igroup = ... //some group on a command
Group group = igroup.getMetadataObject();

//we could also use the runtime metadata
RuntimeMetadata rm = ... //Obtained from the creation of the Execution

group = rm.getGroup("fully.qualified.name"); 
String contextName = group.getNameInSource();

//The props will contain extension properties
Properties props = group.getProperties();       
      ]]></programlisting>
      
    </sect2>
  </sect1>
  
  <sect1>
    <title>Language Visitors</title>
    
    <sect2>
      <title>Framework</title>
      <para>The Connector API provides a language visitor framework in the com.metamatrix.data.visitor.framework package.   The framework provides utilities useful in navigating and extracting information from trees of language objects.</para>

      <para>The visitor framework is a variant of the Visitor design pattern, which is documented in several popular design pattern references.  The visitor pattern encompasses two primary operations: traversing the nodes of a graph (also known as iteration) and performing some action at each node of the graph.  In this case, the nodes are language interface objects and the graph is really a tree rooted at some node.  The provided framework allows for customization of both aspects of visiting.</para>
      <para>The base LanguageObjectVisitor class defines the visit methods for all leaf language interfaces that can exist in the tree.  The LanguageObject interface defines an acceptVisitor() method – this method will call back on the visit method of the visitor to complete the contract.  A base class with empty visit methods is provided as AbstractLanguageVisitor.  The AbstractLanguageVisitor is just a visitor shell – it performs no actions when visiting nodes and does not provide any iteration.</para>
      <para>The HierarchyVisitor provides the basic code for walking a language object tree.  The HierarchyVisitor performs no action as it walks the tree – it just encapsulates the knowledge of how to walk it.  If your connector wants to provide a custom iteration that walks the objects in a special order (to exclude nodes, include nodes multiple times, conditionally include nodes, etc) then you must either extend HierarchyVisitor or build your own iteration visitor.  In general, that is not necessary.</para>
      <para>The DelegatingHierarchyVisitor is a special subclass of the HierarchyVisitor that provides the ability to perform a different visitor’s processing before and after iteration.  This allows users of this class to implement either pre- or post-order processing based on the HierarchyVisitor.  Two helper methods are provided on DelegatingHierarchyVisitor to aid in executing pre- and post-order visitors.   </para>
    </sect2>
    <sect2>
      <title>Provided Visitors</title>
      <para>The SQLStringVisitor is a special visitor that can traverse a tree of language interfaces and output the equivalent Teiid SQL.  This visitor can be used to print language objects for debugging and logging.  The SQLStringVisitor does not use the HierarchyVisitor described in the last section; it provides both iteration and processing type functionality in a single custom visitor.    </para>
      <para>The CollectorVisitor is a handy utility to collect all language objects of a certain type in a tree. Some additional helper methods exist to do common tasks such as retrieving all elements in a tree, retrieving all groups in a tree, and so on.  </para>
    </sect2>
    <sect2>
      <title>Writing a Visitor</title>
      <para>Writing your own visitor can be quite easy if you use the provided facilities.  If the normal method of iterating the language tree is sufficient, then just follow these steps:</para>
      <para>Create a subclass of AbstractLanguageVisitor.  Override any visit methods needed for your processing.  For instance, if you wanted to count the number of elements in the tree, you need only override the visit(IElement) method.  Collect any state in local variables and provide accessor methods for that state.</para>
      <para>Decide whether to use pre-order or post-order iteration.  In many cases, it doesn’t matter, so if you’re not sure, use pre-order processing.</para>
      <para>Write code to execute your visitor using the utility methods on DelegatingHierarchyVisitor:</para>
      <programlisting><![CDATA[
// Get object tree 
LanguageObject objectTree = …

// Create your visitor initialize as necessary
MyVisitor visitor = new MyVisitor();

// Call the visitor using pre-order visitation
DelegatingHierarchyVisitor.preOrderVisit(visitor, objectTree);

// Retrieve state collected while visiting
int count = visitor.getCount();       
      ]]></programlisting>      
      <para>Often it’s useful to create a static method implementing this sequence of calls within your visitor.</para>
    </sect2>
  </sect1>
  <sect1 id="connector_capabilities">
    <title>Connector Capabilities</title>
    <para>All connectors must return a ConnectorCapabilities class from the Connection.getCapabilities() method. This class is used by the Connector Manager to determine what kinds of commands the connector is capable of executing. A basic implementation of the ConnectorCapabilities interface is supplied at com.metamatrix.data.basic.BasicConnectorCapabilities. This capabilities class specifies that the connector only executes queries and does not support any capability. Teiid recommends that you extend this class and override the necessary methods to specify which capabilities your connector supports.  </para>
    
    <sect2>
      <title>Capability Scope</title>
      <para>The method ConnectorCapabilities.getScope() specifies the scope of a capabilities set. Currently, two scope modes are defined in ConnectorCapabilities.SCOPE: global and per user. Specifying the scope as global means that the capabilities are the same for all connections to this source. Specifying the scope as per user means that the capabilities are potentially different for each user, so capabilities cannot be cached between users.</para>
      <para>The per user mode is significantly slower and usually not necessary, therefore Teiid recommends using the global mode if capabilities of a source are the same across all connections. The BasicConnectorCapabilities implementation specifies global scope.</para>
    </sect2>
    <sect2>
      <title>Execution Modes</title>
      <para>The method ConnectorCapabilities.supportsExecutionMode() is used by the Connector Manager to discover what kinds of commands the connector can support. Constants defining the available execution modes are specified in ConnectorCapabilities.EXECUTION_MODE. Your implementation of ConnectorCapabilities should return true from this method for each execution mode your connector supports.</para>
      <para>The BasicConnectorCapabilities implementation specifies only that it supports the SYNCH_QUERY execution mode.</para>
    </sect2>
    <sect2>
      <title>Capabilities</title>
        <para>The following table lists the capabilities that can be specified in the ConnectorCapabilities class.</para>
        <table frame='all'>
          <title>Available Connector Capabilities</title>
          <tgroup cols='3' align='left' colsep='1' rowsep='1'>
            <colspec colname='c1' colwidth="1*" />
            <colspec colname='c2' colwidth="1*" />
            <colspec colname='c3' colwidth="2*" />
            <thead>
              <row>
                <entry>
                  <para>Capability</para>
                </entry>
                <entry>
                  <para>Requires</para>
                </entry>
                <entry>
                  <para>Description</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>SelectDistinct</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support SELECT DISTINCT in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Joins</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support joins.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OuterJoins</para>
                </entry>
                <entry>
                  <para>Joins</para>
                </entry>
                <entry>
                  <para>Connector can support LEFT and RIGHT OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FullOuterJoins</para>
                </entry>
                <entry>
                  <para>Joins, OuterJoins</para>
                </entry>
                <entry>
                  <para>Connector can support FULL OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AliasedGroup</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support groups in the FROM clause that have an alias.
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfJoins</para>
                </entry>
                <entry>
                  <para>Joins, AliasedGroups</para>
                </entry>
                <entry>
                  <para>Connector can support a self join between two aliased versions of the
                    same group.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InlineViews</para>
                </entry>
                <entry>
                  <para>AliasedGroup</para>
                </entry>
                <entry>
                  <para>Connector can support a named subquery in the FROM clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support WHERE and HAVING clauses.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowLimit</para>
                </entry>
                <entry>
                  <para> </para>
                </entry>
                <entry>
                  <para>Connector can support the limit portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowOffset</para>
                </entry>
                <entry>
                  <para> </para>
                </entry>
                <entry>
                  <para>Connector can support the offset portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AndCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support AND criteria in join conditions of the FROM clause,
                    the WHERE clause, and the HAVING clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support the OR logical criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>NotCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support the NOT logical criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>BetweenCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support the BETWEEN predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria such as “age &gt; 10”.  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaEquals</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaGreaterThan</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&gt;”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaGreaterThanOrEqual</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&gt;=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaLessThan</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&lt;”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaLessThanOrEqual</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&lt;=”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaNotEquals</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support comparison criteria with the operator “&lt;&gt;”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ExistsCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support EXISTS predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support IN predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteriaSubquery</para>
                </entry>
                <entry>
                  <para>Criteria, InCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support IN predicate criteria where values are supplied by a
                    subquery.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>IsNullCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support IS NULL predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para>Criteria</para>
                </entry>
                <entry>
                  <para>Connector can support LIKE criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteriaEscapeCharacter</para>
                </entry>
                <entry>
                  <para>Criteria, LikeCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support LIKE criteria with an ESCAPE character clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteria</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria with a subquery on the
                    right side.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaAll</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria, QuantifiedCompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria using the ALL
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaSome</para>
                </entry>
                <entry>
                  <para>Criteria, CompareCriteria, QuantifiedCompareCriteria</para>
                </entry>
                <entry>
                  <para>Connector can support a quantified comparison criteria using the SOME or ANY
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support the ORDER BY clause in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support GROUP BY and HAVING clauses in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesAvg</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the AVG aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCount</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the COUNT aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCountStar</para>
                </entry>
                <entry>
                  <para>Aggregates, AggregatesCount</para>
                </entry>
                <entry>
                  <para>Connector can support the COUNT(*) aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesDistinct</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the keyword DISTINCT inside an aggregate function.  This
                    keyword indicates that duplicate values within a group of rows will be ignored.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMax</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the MAX aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMin</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the MIN aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesSum</para>
                </entry>
                <entry>
                  <para>Aggregates</para>
                </entry>
                <entry>
                  <para>Connector can support the SUM aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ScalarFunctions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support scalar functions wherever expressions are accepted.
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support “unsearched” CASE expressions anywhere that expressions
                    are accepted.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SearchedCaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support “searched” CASE expressions anywhere that expressions are
                    accepted.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ScalarSubqueries</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support the use of a subquery in a scalar context (wherever an
                    expression is valid).</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CorrelatedSubqueries</para>
                </entry>
                <entry>
                  <para>ScalarSubqueries or QuantifiedCompareCriteria or ExistsCriteria or
                    InCriteriaSubquery</para>
                </entry>
                <entry>
                  <para>Connector can support a correlated subquery that refers back to an element in
                    the outer query.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelectLiterals</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector can support literals in the SELECT clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Unions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Connector support UNIONs</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Intersect</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector supports INTERSECT</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Except</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Connector supports Except</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SetQueryOrderBy</para>
                </entry>
                <entry>
                  <para>Unions, Intersect, or Except</para>
                </entry>
                <entry>
                  <para>Connector supports set queries with an ORDER BY</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FunctionsInGroupBy</para>
                </entry>
                <entry>
                  <para>ScalarFunctions, Aggregates</para>
                </entry>
                <entry>
                  <para>Connector supports functions in the GROUP BY list</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FunctionsInGroupBy</para>
                </entry>
                <entry>
                  <para>ScalarFunctions, Aggregates</para>
                </entry>
                <entry>
                  <para>Connector supports functions in the GROUP BY list</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect2>
      
      <sect2>
        <title>Command Form</title>
        <para>The method ConnectorCapabilities.useAnsiJoin() should return true if the Connector prefers the use of ANSI style join structure for INNER and CROSS joins that are pushed down.</para>
        <para>The method ConnectorCapabilities.requiresCriteria() should return true if the Connector requires criteria for any Query, Update, or Delete.  This is a replacement for the model support property "Where All".</para>
      </sect2>
      
      <sect2>
        <title>Scalar Functions</title>
        <para>The method ConnectorCapabilities.getSupportedFunctions() can be used to specify which scalar functions the connector supports.  The set of possible functions is based on the set of functions supported by Teiid.  This set can be found in the Query Support Booklet documentation.  If the connector states that it supports a function, it must support all type combinations and overloaded forms of that function.</para>
        <para>There are five operators that can also be specified in the supported function list: +, -, *, /, and ||.</para>
      </sect2>

      <sect2>
        <title>Physical Limits</title>
        <para>The method ConnectorCapabilities.getMaxInCriteriaSize() can be used to specify the maximum number of values that can be passed in an IN criteria.  This is an important constraint as an IN criteria is frequently used to pass criteria between one source and another using a dependent join.</para>
        <para>The method ConnectorCapabilities.getMaxFromGroups() can be used to specify the maximum number of FROM Clause groups that can used in a join. -1 indicates there is no limit.</para>
      </sect2>
   </sect1>

</chapter>