<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../../../../../../docbook/custom.dtd">
%CustomDTD;
]>
<chapter id="translator_api">
	<title>Translator Development</title>
	<section>
		<title>Extending the ExecutionFactory Class</title>
		<para>A component called the Connector Manager is controlling access to your translator. This chapter reviews
			the basics of how the Connector Manager interacts with your translator while leaving reference details and
			advanced topics to be covered in later chapters.</para>
        <para>
            A custom translator must extend <code>org.teiid.translator.ExecutionFactory</code>
            to connect and query an enterprise data source. This  extended class must provide a no-arg constructor
            that can be constructed using Java reflection libraries. This Execution Factory need define/override following elements.  
        </para>
        
        <section>
            <title>ConnectionFactory</title>
            <para>Defines the "ConnectionFactory" interface that is expected from resource adapter. This defined as part of 
            class definition using generics while extending the "ExecutionFactory" class</para>
        </section>
        
        <section>
            <title>Connection</title>
            <para>Defines the "Connection" interface that is expected from resource adapter. This defined as part of 
            class definition using generics while extending the "ExecutionFactory" class</para>
        </section>        
        
        <section>
            <title>Configuration Properties</title>
            <para>Every software program requires some external configuration, that defines ways user can alter the behavior of a program.
             If this translator needs configurable properties define a variable for every property  as an attribute in the extended
             "ExecutionFactory" class. Then define a "get" and "set" methods for each of them. Also, annotate each "get" method with
              <code>@TranslatorProperty</code> annotation and provide the metadata about the property. 
             </para>
             <para>
             For example, if you need a property called "foo",  by providing the annotation on 
             these properties, the Teiid tooling will automatically interrogate and provide 
             graphical way to configure your Translator. 
             </para>
                    <programlisting language="Java" role="JAVA"><![CDATA[private String foo = "blah";
@TranslatorProperty(display="Foo property", description="description about Foo") 
public String getFoo() 
{
   return foo;
}

public void setFoo(String value) 
{
   return this.foo = value;
}]]> </programlisting>
                    <para>
                    Only java primitive (int), primitive object wrapper (java.lang.Integer), or Enum types are supported as Translator properties. 
                    The default value will be derived from calling the getter, if available, on a newly constructed instance. 
                    All properties <emphasis>should</emphasis> have a default value. If there is no applicable default, then the property should be marked in the annotation as required.  
                    Initialization will fail if a required property value is not provided.
                </para>
                
                <para>The <code>@TranslatorProperty</code> defines the following metadata that you can define about your property</para>
                <itemizedlist>
                    <listitem>
                        <para>display: Display name of the property</para>
                    </listitem>
                    <listitem>
                        <para>description: Description about the property</para>
                    </listitem>
                    <listitem>
                      <para>required: The property is a required property</para>
                    </listitem>
                    <listitem>
                      <para>advanced: This is advanced property; A default should be provided. A property can not be "advanced" and "required" at same time.</para>
                    </listitem>    
                    <listitem>
                      <para>masked: The tools need to mask the property; Do not show in plain text; used for passwords</para>
                    </listitem>                 
                </itemizedlist>                
        </section> 
            
        <section>
            <title>Initializing the Translator</title>
            <para>Override and implement the <code>start</code> method (be sure to call
                    "super.start()") if your translator needs to do any initializing before it is used by the Teiid engine. This method 
                    will be called by Teiid, once after all the configuration properties set above are injected into the class. </para>
        </section>  
        
        <section>
            <title>TranslatorCapabilities</title>
            <para>These are various methods that typically begin with method 
                    signature "supports" on the "ExecutionFactory" class. These methods need to be overridden to describe the execution 
                    capabilities of the Translator.  Refer to <xref linkend="translator_capabilities"/> for more on these methods.</para>
        </section>     
        
        <section>
            <title>Execution (and sub-interfaces)</title>
            <para>Based on types of executions you are supporting, the following methods need to be overridden 
            and need to provide implementations for these methods by extending respective interfaces.</para>
            
            <itemizedlist>
                <listitem>
                    <para><code>createResultSetExecution</code> - Define if you are doing read based operation that is 
                    returning a rows of results.</para>
                </listitem>
                <listitem>
                    <para><code>createUpdateExecution</code> - Define if you are doing write based operations.</para>
                </listitem>
                <listitem>
                    <para><code>createProcedureExecution</code> - Define if you are doing procedure based operations.</para>
                </listitem>
            </itemizedlist>       
            <para>You can choose to implement all the execution modes or just what you need. See more details on this below.</para>     
        </section>    
        
        <section>
            <title>Metadata</title>
            <para>Override and implement the method <code>getMetadata()</code>, if you want to expose the 
                metadata about the source for use in Dynamic VDBs. This defines the tables, column names, procedures, parameters, etc. for use in the query engine. 
                This method is not yet used by Designer tooling. </para>
        </section>         
        
        <section>
            <title>Logging</title>
            <para>Teiid provides <code>org.teiid.logging.LogManager</code> class for logging purposes. 
                Create a logging context and use the LogManager to log your messages. These will be automatically 
                sent to the main Teiid logs. You can edit the "jboss-log4j.xml" inside "conf" directory of the JBoss AS's profile 
                to add the custom context. Teiid uses Log4J as its underlying logging system.</para>
        </section>     
        
        <section>
            <title>Exceptions</title>
            <para>If you need to bubble up any exception use <code>org.teiid.translator.TranslatorException</code>
                class.</para>
        </section>    
        
        <section>
            <title>Default Name</title>
            <para>Finally, you can define a default instance of your Translator by defining the 
                annotation <code>@Translator</code> on the "ExecutionFactory". When you define this, and after deployment 
                a default instance of this 
                Translator is available any VDB that would like to use by just mentioning its name in its "vdb.xml" configuration file.
                VDB can also override the default properties and define another instance of this Translator too. The name you give here is the short 
                name used every where else in the Teiid configuration to refer to this translator.</para>
        </section>                        
                        
	</section>
    

	<section>
		<title>Connections to Source</title>
		<section>
			<title>Obtaining connections</title>
			<para>The extended "ExecutionFactory" must implement the <code>getConnection()</code> method to
				allow the Connector Manager to obtain a connection. </para>
		</section>
		<section>
			<title>Releasing Connections</title>
			<para>Once the Connector Manager has obtained a connection, it will	use that connection only for the
            	lifetime of the request. Â When the request has completed, the closeConnection() method called on the "ExecutionFactory".
                You must also override this method to properly close the connection.</para>
			<para>
				In cases (such as when a connection is stateful and expensive to
				create), connections should be pooled. If the resource adapter is JEE JCA connector based, then pooling is automatically
                provided by the JBoss AS container. If your resource adapter does not implement the JEE JCA, then connection pooling 
                semantics are left to the user to define on their own.
			</para>
		</section>
	</section>
	
	<section>
	   <title>Executing Commands</title>
	   <section>
			<title>Execution Modes</title>
         <para>
         The Teiid query engine uses the "ExecutionFactory" class to obtain the "Execution" 
         interface for the command it is executing. The actual queries themselves are sent 
         to translators in the form of a set of objects, which are further described in 
         Command Language. Refer to <xref linkend="command_language"/>. Translators are 
         allowed to support any subset of the available execution modes.
         </para>
			
			<table frame='all'>
				<title>Types of Execution Modes</title>
				<tgroup cols='3' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1' colwidth="1*" />
					<colspec colname='c2' colwidth="1*" />
					<colspec colname='c3' colwidth="2*" />
					<thead>
						<row>
							<entry>Execution Interface</entry>
							<entry>Command interface(s)</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<code>ResultSetExecution</code>
							</entry>
							<entry>
								<code>QueryExpression</code>
							</entry>
							<entry>A query corresponding to a SQL SELECT or set query statement.</entry>
						</row>
						<row>
							<entry>
								<code>UpdateExecution</code>
							</entry>
							<entry>
								<code>Insert, Update, Delete, BatchedUpdates</code>
							</entry>
							<entry>An insert, update, or delete, corresponding to a SQL INSERT, UPDATE, or DELETE command
              				</entry>
						</row>
						<row>
							<entry>
								<code>ProcedureExecution</code>
							</entry>
							<entry>
								<code>Call</code>
							</entry>
							<entry>A procedure execution that may return a result set and/or output values.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>All of the execution interfaces extend the base <code>Execution</code>
				interface that defines how executions are
				cancelled and closed.  ProcedureExecution also extends ResultSetExecution, since procedures may also return resultsets.</para>
		</section>
		<section>
			<title>ResultSetExecution</title>
			<para>
				Typically most commands executed against translators are QueryExpression.
				While the command is being executed, the translator provides results via the
				ResultSetExecution's "next" method. The "next" method should return null to indicate the end
				of results. Note: the expected batch size can be obtained from the
				ExecutionContext and used as a hint in fetching results from the EIS.
			</para>
		</section>
		<section>
			<title>Update Execution</title>
			<para>Each execution returns the update count(s) expected by the update command. 
		          If possible BatchedUpdates should be executed atomically.  
		          The ExecutionContext can be used to determine if the execution is already under a transaction.</para>
		</section>
		<section>
			<title>Procedure Execution</title>
			<para>Procedure commands correspond to the execution of a stored	procedure or some other functional
				construct. A procedure takes zero or more input values and can return a result
				set and zero or more output values. Â Examples of procedure execution would be a stored procedure in a
				relational database or a call to a web service.</para>
			<para>If a result set is expected when a procedure is executed, all rows from it will be retrieved via the
				ResultSetExecution interface first. Then, if any output values are expected, they will
				be retrieved via the getOutputParameterValues() method.
			</para>
		</section>
         
		<section>
			<title>Asynchronous Executions</title>
			<para>In some scenarios, a translator needs to execute
				asynchronously and allow the executing thread to perform other work.  To allow this, you should Throw a DataNotAvailableExecption during a retrival method, rather than explicitly waiting or sleeping for the results. The
						DataNotAvailableException may take a delay parameter in its
						constructor to indicate how long the system should wait befor polling
						for results.  Any non-negative value is allowed. 
			</para>
			<para>Since the exection and the associated connection are not closed until the work has completed, care should be taken if using asynchronous executions that hold a lot of state.</para>
		</section>
        
		<section>
			<title>Bulk Execution</title>
			<para>Non batched <code>Insert, Update, Delete</code>
				commands may have <code>Literal</code> values marked as multiValued if the
				capabilities shows support for BulkUpdate. Commands with
				multiValued <code>Literal</code>s represent multiple executions of the same
				command with different values.  As with BatchedUpdates, bulk operations should be executed atomically if possible.
			</para>
		</section>
		<section>
			<title>Command Completion</title>
			<para>All normal command executions end with the calling of <code>close()</code> on the Execution object. Â Your
				implementation of this method should do the appropriate clean-up work for all state created in the Execution object.</para>
		</section>
		<section>
			<title>Command Cancellation</title>
			<para>Commands submitted to Teiid may be aborted in several scenarios:</para>
			<itemizedlist>
				<listitem>
					<para>Client cancellation via the JDBC API (or other client APIs)
					</para>
				</listitem>
				<listitem>
					<para>Administrative cancellation</para>
				</listitem>
				<listitem>
					<para>Clean-up during session termination</para>
				</listitem>
				<listitem>
					<para>Clean-up if a query fails during processing</para>
				</listitem>
			</itemizedlist>
			<para>Unlike the other execution methods, which are handled in a single-threaded manner, 
            calls to cancel happen asynchronously with respect to the execution thread.</para>
			<para>Your connector implementation may choose to do nothing in	response to this cancellation message. In
				this instance, Teiid will call close() on the execution object after
				current processing has completed. Implementing the cancel() method allows for faster
				termination of queries being processed and may allow the underlying data source to terminate its operations
				faster as well.</para>
		</section>
	</section>
	
	<section id="command_language">
  <title>Command Language</title>
  
  <section>
    <title>Language </title>
	<para>
		Teiid sends commands to your Translator in object form. These classes are all defined in the "org.teiid.language"
		package. These objects can be combined to represent any possible
		command that Teiid may send to the Translator. However, it is possible
		to notify Teiid that your Translator can only accept certain kinds of
		constructs via the capabilities defined on the "ExecutionFactory" class. Refer to 
		<xref linkend="translator_capabilities"/> for more information.
	</para>
	<para>The language objects all extend from the <code>LanguageObject</code> interface.
		Language objects should be thought of as a tree where each node is a
		language object that has zero or more child language objects of types
		that are dependent on the current node.</para>
	<para>All commands sent to your Translator are in the form of these
		language trees, where the root of the tree is a subclass of <code>Command</code>.
		Command has several sub-interfaces, namely: 
   </para>     
        <itemizedlist>
            <listitem><para><code>QueryExpression</code></para></listitem>
            <listitem><para><code>Insert</code></para></listitem>
            <listitem><para><code>Update</code></para></listitem>
            <listitem><para><code>Delete</code></para></listitem>
            <listitem><para><code>BatchedUpdates</code></para></listitem>
            <listitem><para><code>Call</code></para></listitem>
        </itemizedlist>        

      <para>
      Important components of	these commands are expressions, criteria, and joins, 
      which are examined in closer detail below. For more on the classes and interfaces 
      described here, refer to the Teiid JavaDocs <ulink url="&javaDocUrl;"/>.
      </para>
	
    <section>
      <title>Expressions</title>
		<para>An expression represents a single value in context, although in
			some cases that value may change as the query is evaluated. Â For
			example, a literal value, such as 5 represents an integer value. Â An
			column reference such as "table.EmployeeName" represents a column in a data source
			and may take on many values while the command is being
			evaluated.</para>
      <itemizedlist>
	<listitem>
		<para>
			<code>Expression</code>
			â base expression interface
		</para>
	</listitem>
	<listitem>
		<para>
			<code>ColumnReference</code>
			â represents an column in the data source
		</para>
	</listitem>
	<listitem>
		<para>
			<code>Literal</code>
			â represents a literal scalar value, but may also be multi-valued in
			the case of bulk updates.
		</para>
	</listitem>
	<listitem>
		<para>
			<code>Function</code>
			â represents a scalar function with parameters that are also Expressions
		</para>
	</listitem>
	<listitem>
		<para>
			<code>AggregateFunction</code>
			â represents an aggregate function which can hold a single expression
		</para>
	</listitem>
	<listitem>
		<para>
			<code>WindowFunction</code>
			â represents an window function which holds an AggregateFunction (which is also used to represent analytical functions) and a WindowSpecification
		</para>
	</listitem>
	<listitem>
		<para>
			<code>ScalarSubquery</code>
			â represents a subquery that returns a single value
		</para>
	</listitem>
	<listitem>
		<para>
			<code>SearchedCase, SearchedWhenClause</code>
			â represents a searched CASE expression. Â The searched CASE
			expression evaluates the criteria in WHEN clauses till one evaluates
			to TRUE, then evaluates the associated THEN clause.
		</para>
	</listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Condition</title>
		<para>A criteria is a combination of expressions and operators that
			evaluates to true, false, or unknown. Â Criteria are most commonly used in the
			WHERE or HAVING clauses.</para>
      
      <itemizedlist>
        <listitem><para><code>Condition</code> â the base criteria interface</para></listitem>        
        <listitem><para><code>Not</code> â used to NOT another criteria</para></listitem>
        <listitem><para><code>AndOr</code> â used to combine other criteria via AND or OR</para></listitem>
        <listitem><para><code>SubuqeryComparison</code> â represents a comparison criteria with a subquery including a quantifier such as SOME or ALL</para></listitem>        
        <listitem><para><code>Comparison</code> â represents a comparison criteria with =, &gt;, &lt;, etc.</para></listitem>        
        <listitem><para><code>BaseInCondition</code> â base class for an IN criteria</para></listitem>        
        <listitem><para><code>In</code> â represents an IN criteria that has a set of expressions for values</para></listitem>        
        <listitem><para><code>SubqueryIn</code> â represents an IN criteria that uses a subquery to produce the value set</para></listitem>
        <listitem><para><code>IsNull</code> â represents an IS NULL criteria</para></listitem>        
        <listitem><para><code>Exists</code> â represents an EXISTS criteria that determines whether a subquery will return any values</para></listitem>
        <listitem><para><code>Like</code> â represents a LIKE/SIMILAR TO/LIKE_REGEX criteria that compares string values</para></listitem>
      </itemizedlist>                  
    </section>
    
    <section>
      <title>The FROM Clause</title>
		<para>The FROM clause contains a list of <code>TableReference</code>'s. Â </para>
      
      <itemizedlist>
        <listitem><para><code>NamedTable</code> â represents a single Table</para></listitem>
        <listitem><para><code>Join</code> â has a left and right <code>TableReference</code> and information on the join between the items</para></listitem>
        <listitem><para><code>DerivedTable</code> â represents a table defined by an inline <code>QueryExpression</code></para></listitem>
      </itemizedlist>
    <para>
        A list of <code>TableReference</code>
        are used by default, in the pushdown query
        when no outer joins are used. If an outer join is used anywhere in the
        join tree, there will be a tree of
        <code>Join</code>
        s with a single root. This latter form
        is the ANSI perfered style. If you wish all pushdown queries containing joins to be in ANSI style have the
        capability "useAnsiJoin" return true. Refer to 
        <xref linkend="command_form_capabilities"/> for more information.
    </para>
    </section>
	<section>
		<title>QueryExpression Structure</title>
		<para><code>QueryExpression</code> is the base for both SELECT queries and set queries.  It may optionally take an
         <code>OrderBy</code> (representing a SQL ORDER BY clause), a <code>Limit</code> (represent a SQL LIMIT clause), or a <code>With</code> (represents a SQL WITH clause).</para>
    </section>      

    <section>
      <title>Select Structure</title>

		<para>Each <code>QueryExpression</code> can be a <code>Select</code> describing the expressions
			(typically elements) being selected and an <code>TableReference</code> specifying the table
			or tables being selected from, along with any join information. Â The
			<code>Select</code> may optionally also supply an <code>Condition</code> (representing a SQL
			WHERE clause), a <code>GroupBy</code> (representing a SQL GROUP BY clause), an
			an <code>Condition</code> (representing a SQL HAVING clause).</para>
    </section>
    
    <section>
      <title>SetQuery Structure</title>

		<para>A <code>QueryExpression</code> can also be a <code>SetQuery</code> that represents on of the SQL set operations (UNION,
			INTERSECT, EXCEPT) on two <code>QueryExpression</code>. The all flag may be set to
			indicate UNION ALL (currently INTERSECT and EXCEPT ALL are not allowed in Teiid)</para>
    </section>
    
    <section>
      <title>With Structure</title>
      
      <para>A <code>With</code> clause contains named <code>QueryExpressions</code> held by <code>WithItem</code>s that can be 
      referenced as tables in the main <code>QueryExpression</code>.</para>
    
    </section>
        
    <section>    
      <title>Insert Structure</title>

		<para>Each <code>Insert</code> will have a single <code>NamedTable</code> specifying the table being
			inserted into. Â It will also has a list of <code>ColumnReference</code> specifying the columns 
            of the <code>NamedTable</code> that are being inserted into. It also has
            <code>InsertValueSource</code>, which will be a list of 
            Expressions (<code>ExpressionValueSource</code>),  or a <code>QueryExpression</code>, or an Iterator (<code>IteratorValueSource</code>)</para>
    </section>

    <section>
      <title>Update Structure</title>

		<para>Each <code>Update</code> will have a single <code>NamedTable</code> specifying the table being
			updated and list of <code>SetClause</code> entries that specify <code>ColumnReference</code> 
            and <code>Expression</code> pairs for the update.	The Update may optionally provide a criteria 
			<code>Condition</code> specifying which rows should be updated.</para>
    </section>

    <section>
      <title>Delete Structure</title>

		<para>Each <code>Delete</code> will have a single <code>NamedTable</code> specifying the table being
			deleted from. It may also optionally have a criteria specifying which rows should be deleted. Â </para>
    </section>

    <section>
      <title>Call Structure</title>

		<para>Each <code>Call</code> has zero or more <code>Argument</code> objects. The
			<code>Argument</code> objects describe the input parameters, the output result
			set, and the output parameters. Â </para>
    </section>
    
    <section>
      <title>BatchedUpdates Structure </title>
		<para>Each <code>BatchedUpdates</code> has a list of <code>Command</code> objects (which must be either
			<code>Insert</code>, <code>Update</code> or <code>Delete</code>) that compose the batch. </para>    
    </section>
  </section>

  <section>
    <title>Language Utilities</title>
    <para>This section covers utilities available when using, creating, and manipulating the language interfaces.</para>
    
    <section>
      <title>Data Types</title>
      <para>The Translator API contains an interface <code>TypeFacility</code> that defines 
      data types and provides value translation facilities. This interface can be obtained from calling "getTypeFacility()" 
      method on theÂ "ExecutionFactory" class.</para>

	<para>
		The TypeFacitlity interface has methods that support data type
		transformation and detection of appropriate runtime or JDBC types.
		Â The TypeFacility.RUNTIME_TYPES and TypeFacility.RUNTIME_NAMES
		interfaces defines constants for all Teiid runtime data types. Â All
		<code>Expression</code> instances define a data type based on this set of types.
		Â These constants are often needed in understanding or creating language interfaces.</para>
    </section>

    <section>
      <title>Language Manipulation</title>
		<para>In Translators that support a fuller set of capabilities (those
			that generally are translating to a language of comparable to SQL),
			there is often a need to manipulate or create language interfaces to
			move closer to the syntax of choice. Â Some utilities are provided for
			this purpose:</para>
		<para>Similar to the TypeFacility, you can call "getLanguageFactory()" method on 
            the "ExecutionFactory"
			to get a reference to the <code>LanguageFactory</code> instance for your
			translator. Â This interface is a factory that can be used to create new
			instances of all the concrete language interface objects. Â </para>
		<para>Some helpful utilities for working with <code>Condition</code> objects are
			provided in the <code>LanguageUtil</code> class. Â This class has methods to combine
			<code>Condition</code> with AND or to break an <code>Condition</code> apart based on AND
			operators. Â These utilities are helpful for breaking apart a criteria
			into individual filters that your translator can implement.</para>
    </section>      
  </section>  
    
  <section>
    <title>Runtime Metadata</title>
		<para>Teiid uses a library of metadata, known as "runtime metadata" for
			each virtual database that is deployed in Teiid. The runtime metadata
			is a subset of metadata as defined by models in the Teiid models that
			compose the virtual database. Â While builing your VDB in the Designer, you can define what 
            called "Extension Model", that defines any number of arbitary properties on a model and its objects.
            At runtime, using this runtime metadata interface, you get access to those set properties defined during the 
            design time, to define/hint any execution behavior.</para>
                    
		<para>Translator gets access to the <code>RuntimeMetadata</code> interface at the time of <code>Excecution</code> creation.
            Translators can access runtime metadata by using the interfaces
			defined in <code>org.teiid.metadata</code> package. Â This package defines
			API representing a Schema, Table, Columns and Procedures, and ways to navigate these objects.</para>

    <section>
      <title>Metadata Objects</title>
      <para>All the language objects extend <code>AbstractMetadataRecord</code> class</para>
      <itemizedlist>
        <listitem><para>Column - returns Column metadata record</para></listitem>
        <listitem><para>Table - returns a Table metadata record</para></listitem>
        <listitem><para>Procedure - returns a Procedure metadata record</para></listitem>
        <listitem><para>ProcedureParameter - returns a Procedure Parameter metadata record</para></listitem>
      </itemizedlist>

      <para>Once a metadata record has been obtained, it is possible to use its metadata about that object or to find other related metadata.</para>
    </section>
    <section>
      <title>Access to Runtime Metadata</title>

		<para>The RuntimeMetadata interface is passed in for the creation of an "Execution". See "createExecution" 
            method on the "ExecutionFactory" class. It provides the ability to look up
			metadata records based on their fully qualified names in the VDB.</para>
			
			<example>
				<title>Obtaining Metadata Properties</title>
				      <para>The process of getting a Table's properties is sometimes needed for translator development. Â For example 
      to get the "NameInSource" property or all extension properties:</para>
      <programlisting language="Java" role="JAVA"><![CDATA[//getting the Table metadata from an Table is straight-forward
Table table = runtimeMetadata.getTable("table-name");
String contextName = table.getNameInSource();

//The props will contain extension properties
Map<String, String> props = table.getProperties();]]></programlisting>
			</example>
      
    </section>
  </section>
  
  <section>
    <title>Language Visitors</title>
    
    <section>
      <title>Framework</title>
		<para>The API provides a language visitor framework in the
			<code>org.teiid.language.visitor</code> package. Â The framework
			provides utilities useful in navigating and extracting information
			from trees of language objects.</para>
	
		<para>The visitor framework is a variant of the Visitor design pattern,
			which is documented in several popular design pattern references. Â The
			visitor pattern encompasses two primary operations: traversing the
			nodes of a graph (also known as iteration) and performing some action
			at each node of the graph. Â In this case, the nodes are language
			interface objects and the graph is really a tree rooted at some node.
			Â The provided framework allows for customization of both aspects of
			visiting.</para>
		<para>The base <code>AbstractLanguageVisitor</code> class defines the visit methods
			for all leaf language interfaces that can exist in the tree. Â The
			LanguageObject interface defines an acceptVisitor() method â this
			method will call back on the visit method of the visitor to complete
			the contract. Â A base class with empty visit methods is provided as
			AbstractLanguageVisitor. Â The AbstractLanguageVisitor is just a
			visitor shell â it performs no actions when visiting nodes and does
			not provide any iteration.</para>
		<para>The <code>HierarchyVisitor</code> provides the basic code for walking a
			language object tree. Â <code>The HierarchyVisitor</code> performs no action as it
			walks the tree â it just encapsulates the knowledge of how to walk it.
			Â If your translator wants to provide a custom iteration that walks the
			objects in a special order (to exclude nodes, include nodes multiple
			times, conditionally include nodes, etc) then you must either extend
			HierarchyVisitor or build your own iteration visitor. Â In general,
			that is not necessary.</para>
		<para>The <code>DelegatingHierarchyVisitor</code> is a special subclass of the
			HierarchyVisitor that provides the ability to perform a different
			visitorâs processing before and after iteration. Â This allows users of
			this class to implement either pre- or post-order processing based on
			the HierarchyVisitor. Â Two helper methods are provided on
			<code>DelegatingHierarchyVisitor</code> to aid in executing pre- and post-order
			visitors. Â  </para>
    </section>
    <section>
      <title>Provided Visitors</title>
		<para>The <code>SQLStringVisitor</code> is a special visitor that can traverse a
			tree of language interfaces and output the equivalent Teiid SQL. Â This
			visitor can be used to print language objects for debugging and
			logging. Â The <code>SQLStringVisitor</code> does not use the <code>HierarchyVisitor</code>
			described in the last section; it provides both iteration and
			processing type functionality in a single custom visitor. Â  Â </para>
		<para>The <code>CollectorVisitor</code> is a handy utility to collect all language
			objects of a certain type in a tree. Some additional helper methods
			exist to do common tasks such as retrieving all elements in a tree,
			retrieving all groups in a tree, and so on. Â </para>
    </section>
    <section>
      <title>Writing a Visitor</title>
		<para>Writing your own visitor can be quite easy if you use the
			provided facilities. Â If the normal method of iterating the language
			tree is sufficient, then just follow these steps:</para>
		<para>Create a subclass of AbstractLanguageVisitor. Â Override any visit
			methods needed for your processing. Â For instance, if you wanted to
			count the number of elements in the tree, you need only override the
			<code>visit(ColumnReference)</code> method. Â Collect any state in local variables and
			provide accessor methods for that state.</para>
		<para>Decide whether to use pre-order or post-order iteration. Note
			that visitation order is based upon syntax ordering of SQL clauses -
			not processing order.</para>
		<para>Write code to execute your visitor using the utility methods on
			DelegatingHierarchyVisitor:</para>
      <programlisting language="Java" role="JAVA"><![CDATA[// Get object tree 
LanguageObject objectTree = â¦

// Create your visitor initialize as necessary
MyVisitor visitor = new MyVisitor();

// Call the visitor using pre-order visitation
DelegatingHierarchyVisitor.preOrderVisit(visitor, objectTree);

// Retrieve state collected while visiting
int count = visitor.getCount();]]></programlisting>      
    </section>
  </section>
  <section id="translator_capabilities">
    <title>Translator Capabilities</title>
	<para>The <code>ExecutionFactory</code> class defines all the methods that describe the capabilities of a Translator. 
       These are used by the Connector Manager to determine what kinds of commands the translator is
		capable of executing. A base  <code>ExecutionFactory</code> class implements all the basic capabilities methods, which says
        your translator does not support any capabilities. Your extended 
        <code>ExecutionFactory</code> class must override the the necessary methods to specify which
		capabilities your translator supports. Â You should consult the debug log of query planning (set showplan debug) to see if desired pushdown requires additional capabilities.</para>
    <section>
      <title>Capability Scope</title>
		<para>
			Note that if your capabilities will remain unchanged for the lifetime
			of the translator, since the engine will cache them for reuse by all instances of that
			translator.  Capabilities based on connection/user are not supported.
		</para>
    </section>
    <section>
      <title>Capabilities</title>
        <para>The following table lists the capabilities that can be specified in the <code>ExecutionFactory</code> class.</para>
        <table frame='all'>
          <title>Available Capabilities</title>
          <tgroup cols='3' align='left' colsep='1' rowsep='1'>
            <colspec colname='c1' colwidth="1*" />
            <colspec colname='c2' colwidth="1*" />
            <colspec colname='c3' colwidth="3*" />
            <thead>
              <row>
                <entry>
                  <para>Capability</para>
                </entry>
                <entry>
                  <para>Requires</para>
                </entry>
                <entry>
                  <para>Description</para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <para>SelectDistinct</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support SELECT DISTINCT in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelectExpression</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support SELECT of more than just column references.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AliasedTable</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support Tables in the FROM clause that have an alias.
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InnerJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support inner and cross joins</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfJoins</para>
                </entry>
                <entry>
                  <para>AliasedGroups and at least on of the join type supports.</para>
                </entry>
                <entry>
                  <para>Translator can support a self join between two aliased versions of the
                    same Table.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OuterJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support LEFT and RIGHT OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FullOuterJoins</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support FULL OUTER JOIN.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InlineViews</para>
                </entry>
                <entry>
                  <para>AliasedTable</para>
                </entry>
                <entry>
                  <para>Translator can support a named subquery in the FROM clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>BetweenCriteria</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Not currently used - between criteria is rewriten as compound comparisions.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaEquals</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support comparison criteria with the operator "=".</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CompareCriteriaOrdered</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support comparison criteria with the operator "&gt;" or "&lt;".</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support LIKE criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeCriteriaEscapeCharacter</para>
                </entry>
                <entry>
                  <para>LikeCriteria</para>
                </entry>
                <entry>
                  <para>Translator can support LIKE criteria with an ESCAPE character clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SimilarTo</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support SIMILAR TO criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>LikeRegexCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support LIKE_REGEX criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteria</para>
                </entry>
                <entry>
                  <para>MaxInCriteria</para>
                </entry>
                <entry>
                  <para>Translator can support IN predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InCriteriaSubquery</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support IN predicate criteria where values are supplied by a
                    subquery.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>IsNullCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support IS NULL predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the OR logical criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>NotCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
					<para>Translator can support the NOT logical criteria. IMPORTANT: This
						capability also applies to negation of predicates, such as specifying
						IS NOT NULL, "&lt;=" (not "&gt;"), "&gt;=" (not "&lt;"), etc.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ExistsCriteria</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support EXISTS predicate criteria.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaAll</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support a quantified comparison criteria using the ALL
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>QuantifiedCompareCriteriaSome</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support a quantified comparison criteria using the SOME or ANY
                    quantifier.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support the ORDER BY clause in queries.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderByUnrelated</para>
                </entry>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para>Translator can support ORDER BY items that are not directly specified in the select clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OrderByNullOrdering</para>
                </entry>
                <entry>
                  <para>OrderBy</para>
                </entry>
                <entry>
                  <para>Translator can support ORDER BY items with NULLS FIRST/LAST.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support an explict GROUP BY clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Having</para>
                </entry>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para>Translator can support the HAVING clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesAvg</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the AVG aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCount</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the COUNT aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesCountStar</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the COUNT(*) aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesDistinct</para>
                </entry>
                <entry>
                  <para>At least one of the aggregate functions.</para>
                </entry>
                <entry>
                  <para>Translator can support the keyword DISTINCT inside an aggregate function. Â This
                    keyword indicates that duplicate values within a group of rows will be ignored.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMax</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the MAX aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesMin</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the MIN aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesSum</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the SUM aggregate function.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AggregatesEnhancedNumeric</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the VAR_SAMP, VAR_POP, STDDEV_SAMP, STDDEV_POP aggregate functions.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ScalarSubqueries</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support the use of a subquery in a scalar context (wherever an
                    expression is valid).</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CorrelatedSubqueries</para>
                </entry>
                <entry>
                  <para>At least one of the subquery pushdown capabilities.</para>
                </entry>
                <entry>
                  <para>Translator can support a correlated subquery that refers to an element in
                    the outer query.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Not currently used - simple case is rewriten as searched case.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SearchedCaseExpressions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator can support "searched" CASE expressions anywhere that expressions are
                    accepted.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Unions</para>
                </entry>
                <entry>
                  <para />
                </entry>
                <entry>
                  <para>Translator support UNION and UNION ALL</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Intersect</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports INTERSECT</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Except</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports Except</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SetQueryOrderBy</para>
                </entry>
                <entry>
                  <para>Unions, Intersect, or Except</para>
                </entry>
                <entry>
                  <para>Translator supports set queries with an ORDER BY</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowLimit</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the limit portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RowOffset</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator can support the offset portion of the limit clause</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>FunctionsInGroupBy</para>
                </entry>
                <entry>
                  <para>GroupBy</para>
                </entry>
                <entry>
                  <para>Translator can support non-column reference grouping expressions.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>InsertWithQueryExpression</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports INSERT statements with values specified by an QueryExpression.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>supportsBatchedUpdates</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports a batch of INSERT, UPDATE and DELETE commands to be executed together.</para>
                </entry>
              </row>   
              <row>
                <entry>
                  <para>BulkUpdate</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports updates with multiple value sets</para>
                </entry>
              </row>         
              <row>
                <entry>
                  <para>InsertWithIterator</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports inserts with an iterator of values.  The values would typically be from an evaluated QueryExpression.</para>
                </entry>
              </row>         
              <row>
                <entry>
                  <para>CommonTableExpressions</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports the WITH clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ElementaryOlapOperations</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports window functions and analytic functions RANK, DENSE_RANK, and ROW_NUMBER.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>WindowOrderByWithAggregates</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports windowed aggregates with a window order by clause.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>AdvancedOlapOperations</para>
                </entry>
                <entry>
                  <para/>
                </entry>
                <entry>
                  <para>Translator supports aggregate conditions.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
		<para>Note that any pushdown subquery must itself be compliant with the	Translator capabilities.</para>
      </section>
      
      <section id="command_form_capabilities">
        <title>Command Form</title>
		<para>The method <code>ExecutionFactory.useAnsiJoin()</code> should return true
			if the Translator prefers the use of ANSI style join structure for
			join trees that contain only INNER and CROSS joins.</para>
		<para>The method <code>ExecutionFactory.requiresCriteria()</code> should return
			true if the Translator requires criteria for any Query, Update, or
			Delete. This is a replacement for the model support property "Where
			All".</para>
      </section>
      
      <section>
        <title>Scalar Functions</title>
		<para>The method <code>ExecutionFactory.getSupportedFunctions()</code> can be
			used to specify which scalar functions the Translator supports. Â The
			set of possible functions is based on the set of functions supported
			by Teiid.  This set can be found in the Reference documentation at
            <ulink url="&docUrl;"/>.  If the Translator states that it supports a function,
			it must support all type combinations and overloaded forms of that
			function.</para>
		<para>There are also five standard operators that can also be specified in the
			supported function list: +, -, *, /, and ||.</para>
		<para>The constants interface SourceSystemFunctions contains the string
			names of all possible built-in pushdown functions. Note that not all
			system functions appear in this list. This is because some system
			functions will always be evaluted in Teiid, are simple aliases to
			other functions, or are rewriten to a more standard expression.</para>
      </section>

      <section>
        <title>Physical Limits</title>
		<para>The method <code>ExecutionFactory.getMaxInCriteriaSize()</code> can be
			used to specify the maximum number of values that can be passed in an
			IN criteria. Â This is an important constraint as an IN criteria is
			frequently used to pass criteria between one source and another using
			a dependent join.</para>
	    <para>The method <code>ExecutionFactory.getMaxDependentInPredicates()</code> is
			used to specify the maximum number of IN predicates (of at most MaxInCriteriaSize) that can be passed
			as part of a dependent join.  For example if there are 10000 values to pass as part of the dependent join
			and a MaxInCriteriaSize of 1000 and a MaxDependentInPredicates setting of 5, then the 
			dependent join logic will form two source queries each with 5 IN predicates of 1000 values each combined by OR.</para>
		<para>The method <code>ExecutionFactory.getMaxFromGroups()</code> can be used
			to specify the maximum number of FROM Clause groups that can used in a
			join. -1 indicates there is no limit.</para>
      </section>
      
      <section>
        <title>Update Execution Modes</title>
		<para>The method <code>ExecutionFactory.supportsBatchedUpdates()</code> can be
			used to indicate that the Translator supports executing the <code>BatchedUpdates</code> command.
			</para>
		<para>The method <code>ExecutionFactory.supportsBulkUpdate()</code> can be used
			to indicate that the Translator accepts update commands containg multi valued Literals.</para>
		<para>Note that if the translator does not support either of these
			update modes, the query engine will compensate by issuing the updates 	individually.</para>
      </section>
      
      <section>
      	<title>Default Behavior</title>
      	<para>The method <code>ExecutionFactory.getDefaultNullOrder()</code> specifies the default null order.  Can be one of UNKNOWN, LOW, HIGH, FIRST, LAST.  This is only used if ORDER BY is supported, but null ordering is not.</para>
      </section>
      
   </section>

</section>
    	<section>
		<title>Large Objects</title>
		<para>This section examines how to use facilities provided by the Teiid
		API to use large objects such as blobs, clobs, and xml in
		your Translator.</para>
		<section>
			<title>Data Types</title>
			<para>Teiid supports three large object runtime data types: Â blob,
				clob, and xml.	 A blob is a "binary large object", a clob is a
				"character large object", and "xml" is a "xml
				document".  Columns modeled as a blob, clob, or xml are treated similarly by
				the	translator framework to support memory-safe streaming. Â </para>
		</section>
		<section>
			<title>Why Use Large Object Support?</title>
			<para>Teiid allows a Translator to return a large object through the
				Teiid translator API by just returning a reference to the actual
				large object. Â Access to that LOB will be streamed as appropriate rather
				than retrieved all at once. Â This is useful for several reasons:</para>
			<orderedlist>
				<listitem>
					<para>Reduces memory usage when returning the result set to the user.</para>
				</listitem>
				<listitem>
					<para>Improves performance by passing less data in the result set.</para>
				</listitem>
				<listitem>
					<para>Allows access to large objects when needed rather than assuming that users will
						always use the large object data.</para>
				</listitem>
				<listitem>
					<para>Allows the passing of arbitrarily large data values.</para>
				</listitem>
			</orderedlist>
			<para>However, these benefits can only truly be gained if the Translator itself does not
				materialize an entire large object all at once. Â For example, the Java JDBC API
				supports a	streaming interface for blob and clob data.</para>
		</section>
		
			<section>
		<title>Handling Large Objects</title>
		<para>The Translator API automatically handles large objects	(Blob/Clob/SQLXML) through
			the creation of special purpose wrapper	objects when it retrieves results.
    </para>

		<para>Once the wrapped object is returned, the streaming of LOB is
			automatically supported. These LOB objects then can for example appear
			in client results, in user defined functions, or sent to other translators.</para>

		<para>A Execution is usually closed and the underlying
			connection is either closed/released as soon as all rows for that
			execution have been retrieved.Â However, LOB	objects may need to be
			read after their initial retrieval of results. Â When LOBs are detected
			the default closing behavior	is prevented by setting a flag on the
			ExecutionContext. See ExecutionContext.keepAlive() method. </para>

		<para>When the "keepAlive" alive flag is set, then the execution object is only closed when user's Statement is closed.</para>

		<programlisting language="Java" role="JAVA"><![CDATA[executionContext.keepExecutionAlive(true);]]></programlisting>

	</section>

	<section>
		<title>Inserting or Updating Large Objects</title>
		<para>LOBs will be passed to the Translator in the
			language objects as Literal containing a java.sql.Blob, java.sql.Clob, or
			java.sql.SQLXML. Â You can use these interfaces to retrieve the data in
			the large object and use it for insert or update.</para>
	</section>
		
	</section>
    
    <section id="translator_package">
        <title>Packaging</title>
        <para>
        Once the "ExecutionFactory" class is implemented, package it in a JAR file. The only 
        additional requirement is provide a file called "jboss-beans.xml" in the "META-INF" 
        directory of the JAR file, with following contents.  Replace ${name} with name of your 
        translator, and replace ${execution-factory-class} with your overridden ExecutionFactory 
        class name. This will register the Translator for use with tooling and Admin API.
        </para>
        <programlisting role="XML" language="XML"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<deployment xmlns="urn:jboss:bean-deployer:2.0">

   <bean name="translator-${name}-template" class="org.teiid.templates.TranslatorDeploymentTemplate">
      <property name="info"><inject bean="translator-${name}"/></property>
      <property name="managedObjectFactory"><inject bean="ManagedObjectFactory"/></property>
   </bean>

   <bean name="translator-${name}" class="org.teiid.templates.TranslatorTemplateInfo">
      <constructor factoryMethod="createTemplateInfo">
         <factory bean="TranslatorDeploymentTemplateInfoFactory"/>
         <parameter class="java.lang.Class">org.teiid.templates.TranslatorTemplateInfo</parameter>
         <parameter class="java.lang.Class">${execution-factory-class}</parameter>
         <parameter class="java.lang.String">translator-${name}</parameter>
         <parameter class="java.lang.String">${name}</parameter>         
      </constructor>
   </bean> 

</deployment>]]></programlisting>
                
                
    </section>
    
    <section id="translator_deploy">
        <title>Deployment</title>
        <para>Copy the JAR file that defines the Translator into "deploy" directory of the JBoss AS's chosen profile, and 
        the Translator will be deployed automatically. There is no restriction that, JBoss AS need to be restarted. However, if your Translator
        has external dependencies to other JAR libraries, they need to be placed inside the "lib" directory of the JBoss AS's profile. 
        This will require a restart of the JBoss Server. Another option to avoid the restart is to bundle all the required JAR files into 
        the same JAR file as the Translator. It is user's responsibility to make sure they are not running into any conflicts with their
        dependent libraries with those already exist in the JBoss environment.</para>
    </section>    
</chapter>