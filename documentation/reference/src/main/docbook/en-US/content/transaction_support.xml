<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="transaction_support">
	<title>Transaction Support</title>
	<para>
		Teiid utilizes XA transactions for participating in global
		transactions and for demarcating its local and command scoped
		transactions.
		<ulink url="http://www.jboss.org/jbosstm/">JBoss Transactions</ulink>
		is used by Teiid as its transaction manager. See
		<ulink url="http://www.jboss.org/jbosstm/docs/index.html"> this documentation</ulink>
		for the advanced features provided by JBoss Transactions.
	</para>
	<table>
		<title>Teiid Transaction Scopes</title>
		<tgroup cols="2">
			<thead>
				<row>
					<entry>Scope</entry>
					<entry>Description</entry>
				</row>
			</thead>
			<tbody>
				<row>
					<entry>Command</entry>
					<entry>
						Treats the user command as if all source commands are executed
						within the scope of the same transaction. The
						<link linkend="autowrap">AutoCommitTxn</link>
						execution property controls the behavior of command level
						transactions.
					</entry>
				</row>
				<row>
					<entry>Local</entry>
					<entry>The transaction boundary is local defined by a single
						client session.</entry>
				</row>
				<row>
					<entry>Global</entry>
					<entry>Teiid participates in a global transaction as an
						XA Resource.</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
	<para>The default transaction isolation level for Teiid is READ_COMMITTED.</para> 
	<sect1 id="autowrap">
		<title>AutoCommitTxn Execution Property</title>
		<para>Since user level commands may execute multiple source
			commands, users can specify the AutoCommitTxn execution property to
			control the transactional behavior of a user command when not in a
			local or global transaction.</para>
		<table>
			<title>AutoCommitTxn Settings</title>
			<tgroup cols="2">
				<colspec colwidth="1*" />
				<colspec colwidth="3*" />
				<thead>
					<row>
						<entry>Setting</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>OFF</entry>
						<entry>Do not wrap each command in a transaction. Individual
							source commands may commit or rollback regardless of the success
							or failure of the overall command.</entry>
					</row>
					<row>
						<entry>ON</entry>
						<entry>Wrap each command in a transaction. This mode is the
							safest, but may introduce performance overhead.</entry>
					</row>
					<row>
						<entry>AUTO</entry>
						<entry>
						    This is the default setting. Will automatically wrap commands in a transaction, but only if
							the command seems to be transactionally unsafe.
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		<para>The concept of command safety with respect to a transaction
			is determined by Teiid based upon command type, the transaction isolation level, and available
			metadata.  A wrapping transaction is not needed if:
			<itemizedlist>
				<listitem>
					<para>If a user command is fully pushed to the source.
					</para>
				</listitem>
				<listitem>
					<para>If the user command is a SELECT (including XML) or an XQuery and the transaction isolation is not REPEATABLE_READ nor SERIALIABLE.
					</para>
				</listitem>
				<listitem>
					<para>If the user command is a stored procedure and the transaction isolation is not REPEATABLE_READ nor SERIALIABLE and the 
					<link linkend="updating_model_count">updating model count</link> is zero.
					</para>
				</listitem>
			</itemizedlist>
	    </para>
		<para>The update count may be set on all procedures as part of 
			the procedure metadata in the model.</para>
	</sect1>
	<sect1 id="updating_model_count">
		<title>Updating Model Count</title>
		<para>The term "updating model count" refers to the number of times
			any model is updated during the execution of a command. It is used to
			determine whether a transaction, of any scope, is required to safely
			execute the command.</para>
		<table>
			<title>Updating Model Count Settings</title>
			<tgroup cols="2">
				<colspec colwidth=".5*" />
				<colspec colwidth="2*" />
				<colspec colwidth="1.5*" />
				<thead>
					<row>
						<entry>Count</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>0</entry>
						<entry>No updates are performed by this command.</entry>
					</row>
					<row>
						<entry>1</entry>
						<entry>Indicates that only one model is updated by this
							command (and its subcommands). Also the success or failure of
							that update corresponds to the success of failure of the command.
							It should not be possible for the update to succeed while the
							command fails. Execution is not considered transactionally
							unsafe.</entry>
					</row>
					<row>
						<entry>*</entry>
						<entry>Any number greater than 1 indicates that exection is
							transactionally unsafe and an XA transaction will be required.
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	</sect1>
	<sect1>
		<title>JDBC and Transactions</title>
		<sect2>
			<title>JDBC API Functionality</title>
			<itemizedlist>
				<para>The transaction scopes above map to these JDBC modes:
				</para>
				<listitem>
					<para>Command - Connection autoCommit property set to true.
					</para>
				</listitem>
				<listitem>
					<para>
						Local - Connection autoCommit property set to false. The
						transaction is committed by setting autoCommit to true or calling
						<function>java.sql.Connection.commit
						</function>
						. The transaction can be rolled back by a call to
						<function>java.sql.Connection.rollback
						</function>
					</para>
				</listitem>
				<listitem>
					<para>
						Global - the XAResource interface provided by an XAConnection is
						used to control the transaction. Note that XAConnections are
						available only if Teiid is consumed through its XADataSource,
						<classname>com.metamatrix.jdbc.MMDataSource
						</classname>
						. JEE containers or data access APIs typically control XA
						transactions on behalf of application code.
					</para>
				</listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>J2EE Usage Models</title>
			<itemizedlist>
				<para>J2EE provides three ways to manage transactions for beans:
				</para>
				<listitem>
					<para>Client-controlled – the client of a bean
						begins and ends a transaction explicitly.</para>
				</listitem>
				<listitem>
					<para>Bean-managed – the bean itself begins and ends a
						transaction explicitly.</para>
				</listitem>
				<listitem>
					<para>Container-managed – the app server container
						begins and ends a transaction automatically.</para>
				</listitem>
			</itemizedlist>
			<para>In any of these cases, transactions may be either local or XA
				transactions, depending on how the code and descriptors are written.
				Some kinds of beans (stateful session beans and entity beans) are
				not required by the spec to support non-transactional sources,
				although the spec does allow an app server to optionally support
				this with the caution that this is not portable or predictable.
				Generally speaking, to support most typical EJB activities in a
				portable fashion requires some kind of transaction support.</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Limitations and Workarounds</title>
		<itemizedlist>
			<listitem>
				<para>The client setting of transaction isolation level is not
					propogated to the connectors. The transaction isolation level can be set on each XA
					connector, however this isolation level is fixed and cannot be
					changed at runtime for specific connections/commands.</para>
			</listitem>
			<listitem>
				<para>Temporary tables are not transactional. For example,
					a global temporary table will retain all inserts performed during a
					local transaction that was rolled back.</para>
			</listitem>
			<!-- <listitem>
				<para>Connectors may be set to immutable to prevent their
					participation in transactions. This is useful in situations where
					update commands are being issued against a source that lacks XA
					transaction capabilities.</para>
			</listitem>-->
		</itemizedlist>
	</sect1>
</chapter>